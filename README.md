# ğŸ“™ Today I Learned

## ê·œì¹™

- ê¸°ì–µì— ë‚¨ëŠ” ë‚´ìš© ê¸°ë¡ í›„ [ì •ì  ì›¹í˜ì´ì§€](https://lee20h.github.io/TIL/)ì— ì •ë¦¬
- Github Actionìœ¼ë¡œ ë°°í¬
- markdownìœ¼ë¡œ ì‘ì„±
- ë¬¸ì œ í’€ê³  [Problem Solving](https://github.com/lee20h/TIL/tree/master/Problem%20Solving) í´ë”ì— ëª¨ìœ¼ê¸°

---

# 2020ë…„

| [5ì›”](./years/2020/5ì›”.md) | [6ì›”](./years/2020/6ì›”.md) | [7ì›”](./years/2020/7ì›”.md) | [8ì›”](./years/2020/8ì›”.md) | [9ì›”](./years/2020/9ì›”.md) | [10ì›”](./years/2020/10ì›”.md) | [11ì›”](./years/2020/11ì›”.md) | [12ì›”](./years/2020/12ì›”.md) |
| -------------------------- | -------------------------- | -------------------------- | -------------------------- | -------------------------- | ---------------------------- | ---------------------------- | ---------------------------- |

---

# 2021ë…„

| [1ì›”](./years/2021/1ì›”.md) |
| -------------------------- |

---

- 1 æ—¥

# C++ ì •ê·œ í‘œí˜„ì‹

C++ì—ì„œëŠ” C++11ë¶€í„° í‘œì¤€ìœ¼ë¡œ ì¶”ê°€ëœ ì •ê·œ í‘œí˜„ì‹ì— ëŒ€í•´ì„œ ì•Œì•„ë³¼ë ¤ê³  í•œë‹¤.

ì‚¬ìš©ë˜ëŠ” ê°ì²´ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

- `std::regex`
- `std::smatch`, `std::cmatch`

regexëŠ” ì‚¬ìš©í•  ì •ê·œ í‘œí˜„ì‹ì„ ì§€ì •í•˜ë©´ ëœë‹¤.  
smatchì™€ cmatchì˜ ê²½ìš°ì—ëŠ” ë§¤ì¹­ëœ ë¬¸ìì—´ì„ `string` í˜¹ì€ `const char*`ìœ¼ë¡œ ë°˜í™˜í•´ì¤€ë‹¤.

ì‚¬ìš©ë˜ëŠ” í•¨ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

- `std::regex_match`
- `std::regex_search`
- `std::regex_replace`

## í•¨ìˆ˜

- std::regex_match

```cpp
#include <iostream>
#include <string>
#include <regex>
using namespace std;

int main() {
  string str = "100100100110";
  regex reg("(100|110)+");
  smatch m;

  bool flag = regex_match(str, m, reg);
  flag ? cout << "YES" : cout << "NO";
}
```

reg ë³€ìˆ˜ì— ì •ê·œ í‘œí˜„ì‹ì„ ë„£ì€ ë’¤ ì›í•˜ëŠ” ë¬¸ìì—´ê³¼ smatch í˜¹ì€ cmatch ë³€ìˆ˜ë¥¼ regex_match í•¨ìˆ˜ì— íŒŒë¼ë¯¸í„°ë¡œ ë„˜ê²¨ì£¼ë©´ ë°˜í™˜ê°’ì´ boolean ê°’ìœ¼ë¡œ ë°›ì„ ìˆ˜ ìˆë‹¤.

- std::regex_search

searchëŠ” matchì™€ ë§¤ìš° ìœ ì‚¬í•˜ë‹¤. ë‹¤ë¥¸ ì ì€ matchì˜ ê²½ìš°ì—ëŠ” ëª¨ë“  ë¬¸ìì—´ì´ ë‹¤ ì •ê·œ í‘œí˜„ì‹ì— ì¼ì¹˜í•´ì•¼í•˜ëŠ”ë° searchì— ê²½ìš°ì—ëŠ” íŒ¨í„´ì´ ì¼ë¶€ë¼ë„ ë“¤ì–´ê°€ìˆë‹¤ë©´ trueë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤. ë”°ë¼ì„œ ì‚¬ìš©í•˜ëŠ” ì˜ˆì‹œëŠ” matchì™€ ìœ ì‚¬í•˜ë‹¤.

- std::regex_replace

replace í•¨ìˆ˜ëŠ” ì •ê·œ í‘œí˜„ì‹ì— ë§¤ì¹­ë˜ëŠ” ë¬¸ìì—´ì„ ì›í•˜ëŠ” í‘œí˜„ì‹ì— ë§ê²Œ ìˆ˜ì •í•´ì£¼ëŠ” ì—­í• ì„ í•œë‹¤. íŒŒë¼ë¯¸í„°ë¡œëŠ” ë¬¸ìì—´, ì°¾ì„ ì •ê·œì‹, ëŒ€ì²´í•  ì •ê·œì‹ ì´ëŸ¬í•œ ìˆœì„œë¡œ 3ê°€ì§€ë¥¼ ë„£ìœ¼ë©´ ëœë‹¤.

## ë¬¸ì œ í’€ì´

- `1013. Contact`

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	regex reg("(100+1+|01)+");
	smatch m;
	int n;
	cin >> n;
	for (int i=0; i<n; i++) {
		string str;
		cin >> str;
		bool flag = regex_match(str, m, reg);
		flag ? cout << "YES\n" : cout << "NO\n";
	}
}
```

## ë ˆí¼ëŸ°ìŠ¤

- [ì”¹ì–´ë¨¹ëŠ” C++](https://modoocode.com/303)

---

- 2 æ—¥

# PS

- `2023. ì‹ ê¸°í•œ ì†Œìˆ˜`

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> v;
int obj;

bool prime(int n) {
	if(n == 0 || n == 1)
		return false;

	for(int i=2; i*i<=n; i++) {
		if(n % i == 0)
			return false;
	}
	return true;
}

void dfs(int n, int cnt) {
	if(cnt == obj) {
		cout << n << '\n';
		return;
	}

	for (int i=1; i<10; i++) {
		if(prime(n*10+i))
			dfs(n*10+i, cnt+1);
	}
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	cin >> obj;

	for (int i=1; i<=9; i++) {
		if(prime(i))
			dfs(i, 1);
	}
}
```

ì£¼ì–´ì§„ nì˜ ìˆ«ìë§Œí¼ ìë¦¿ìˆ˜ë¥¼ ê°€ì§„ ìˆ«ìë“¤ ì¤‘ 1~nìë¦¿ìˆ˜ê°€ ì „ë¶€ ì†Œìˆ˜ì¸ ìˆ«ìë¥¼ ì¶œë ¥í•˜ëŠ” ë¬¸ì œì´ë‹¤. ê¹Šì´ìš°ì„ íƒìƒ‰ìœ¼ë¡œ ìˆ«ìë¥¼ ë§Œë“¤ê³  ì—ë¼í† ìŠ¤í…Œë„¤ìŠ¤ì˜ ì²´ë¡œ ì†Œìˆ˜ë¥¼ ì²´í¬í•´ì¤˜ì„œ nìë¦¬ ìˆ«ìë§Œí¼ ì»¤ì§€ë©´ í•´ë‹¹ ê°’ì„ ì¶œë ¥í–ˆë‹¤.

ì´ ë¬¸ì œë¡œ ì—ë¼í† ìŠ¤í…Œë„¤ìŠ¤ì˜ ì²´ì™€ ë°±íŠ¸ë˜í‚¹ì„ ë‹¤ì‹œ ê³µë¶€í•  ìˆ˜ ìˆì—ˆë‹¤.

---

- 3 æ—¥

# PS

- `2436. ê³µì•½ìˆ˜`

```cpp
#include <bits/stdc++.h>
using namespace std;

int gcd(int a, int b) {
	return b? gcd(b, a%b) : a;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	int g, l, n;
	long long a, b;
	cin >> g >> l;

	int num = l / g;

	for (int i=1; i*i<=num; i++) {
		if(num%i == 0 && gcd(i, num/i) == 1) {
			n = i;
		}
	}

	a = g * n;
	b = g * (num/n);
	cout << a << ' ' << b;
}

```

ìµœëŒ€ ê³µì•½ìˆ˜ì™€ ìµœì†Œ ê³µë°°ìˆ˜ê°€ ì£¼ì–´ì¡Œì„ ë•Œ í•´ë‹¹ ê°’ì„ êµ¬í•˜ê¸° ìœ„í•œ ë‘ ìì—°ìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤. ìµœëŒ€ ê³µì•½ìˆ˜ë€ ë‘ ìˆ˜ë¥¼ ì„œë¡œì†Œê°€ ë‚˜ì˜¬ ë•Œ ê¹Œì§€ ë‚˜ëˆ„ì—ˆì„ ë•Œ ë‚˜ì˜¨ ê³µì•½ìˆ˜ì˜ ê³±ì´ë©°, ìµœì†Œ ê³µë°°ìˆ˜ëŠ” ìµœëŒ€ ê³µì•½ìˆ˜ì— ë‚˜ë¨¸ì§€ ì„œë¡œì†Œì˜ ê°’ë“¤ì„ ê³±í•´ì¤€ ê°’ì´ë‹¤. ë”°ë¼ì„œ ë‘ ê°’ì˜ ì„œë¡œì†Œë“¤ì˜ ê³±ì„ êµ¬í•œ ë’¤ ê·¸ ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ì•½ìˆ˜ë¥¼ êµ¬í•œë‹¤.

ì•½ìˆ˜ë¥¼ êµ¬í•  ë•ŒëŠ” ì„œë¡œì†Œë“¤ì˜ ê³±ì˜ ì œê³±ê·¼ê¹Œì§€ë§Œ ì•½ìˆ˜ë¥¼ êµ¬í•˜ë©°, ì•½ìˆ˜ì´ë©´ì„œ ì„œë¡œì†Œë“¤ì˜ ê³±ê³¼ ë˜ ì„œë¡œì†Œì¸ ê°’ë“¤ì„ ì°¾ì•„ì„œ ìµœëŒ€ ê³µì•½ìˆ˜ì™€ ê³±í•´ì£¼ë©´ ì›í•˜ëŠ” ê°’ì„ ì°¾ì„ ìˆ˜ ìˆë‹¤.

- `2589. ë³´ë¬¼ì„¬`

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX = 50;

int py[4] = {0, 0, 1, -1};
int px[4] = {1, -1, 0, 0};

char arr[MAX][MAX];
int cache[MAX][MAX];
int w, h;

int bfs(int a, int b) {
	int ans = 0;
	queue<pair<int,int>> q;
	q.push({a,b});
	memset(cache, 0, sizeof(cache));
	cache[a][b] = 1;
	while(!q.empty()) {
		int y = q.front().first;
		int x = q.front().second;
		q.pop();

		for (int i=0; i<4; i++) {
			int dy = y + py[i];
			int dx = x + px[i];
			ans = max(ans, cache[y][x]);
			if(dy < 0 || dx < 0 || dy >= h || dx >= w)
				continue;
			if(arr[dy][dx] == 'W' || cache[dy][dx])
				continue;
			q.push({dy,dx});
			cache[dy][dx] = cache[y][x] + 1;
		}
	}

	return ans-1;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	int ans = 0;
	cin >> h >> w;

	for (int i=0; i<h; i++) {
		for (int j=0; j<w; j++) {
			cin >> arr[i][j];
		}
	}

	for (int i=0; i<h; i++) {
		for (int j=0; j<w; j++) {
			if(arr[i][j] == 'L')
				ans = max(ans,bfs(i, j));
		}
	}

	cout << ans;
}

```

ì§€ë„ì˜ í¬ê¸°ì™€ ì§€ë„ì— ê° íƒ€ì¼ì— ìœ¡ì§€ì™€ ë°”ë‹¤ê°€ ì£¼ì–´ì§„ ë‹¤ìŒì— ìœ¡ì§€ì™€ ìœ¡ì§€ ê±°ë¦¬ ì¤‘ì—ì„œ ê°€ì¥ ê¸´ ë¶€ë¶„ì´ ë³´ë¬¼ìƒìê°€ ìˆëŠ” ê³³ì´ë¼ê³  í•œë‹¤. ì´ ë¬¸ì œì˜ í’€ì´ë¥¼ ë„ˆë¹„ìš°ì„ íƒìƒ‰ì„ í•˜ë˜ ì£¼ì–´ì§„ ì¶œë°œì ì´ ì—†ìœ¼ë¯€ë¡œ ëª¨ë“  ìœ¡ì§€ ì§€ì ì—ì„œ ë„ˆë¹„ìš°ì„ íƒìƒ‰ì„ í•˜ë©°, ê°€ì¥ ê¸´ ì§€ì ì„ ì°¾ì•˜ë‹¤.

ì²« ì‹œë„ëŠ” booleaní˜• ë°°ì—´ì„ ì´ìš©í•˜ì—¬ ë§¤ë²ˆ ì´ˆê¸°í™”ë¥¼ ì‹œì¼œì£¼ë©´ì„œ ì‹œê°„ì„ ì²´í¬í•˜ê³  queue ì»¨í…Œì´ë„ˆì— ì¢Œí‘œ ë¿ì•„ë‹ˆë¼ ì›€ì§ì¸ ê±°ë¦¬ë¥¼ ì§‘ì–´ë„£ì—ˆì—ˆë‹¤. í•˜ì§€ë§Œ, ë‹µì€ ë‚˜ì˜¤ë‚˜ ì‹œê°„ì´ˆê³¼ì˜€ë‹¤.

ë‹¤ìŒ ì‹œë„ëŠ” booleaní˜• ë°°ì—´ì´ ì•„ë‹Œ intí˜• ë°°ì—´ì„ ê°€ì§€ê³  ì›€ì§ì¸ ê±°ë¦¬ë¥¼ ì ë„ë¡ í•˜ì˜€ë‹¤. queue ì»¨í…Œì´ë„ˆì—ì„œ ì¢Œí‘œë§Œ í‘œì‹œí•˜ë©° í•¨ìˆ˜ì˜ ë°˜í™˜í˜•ì„ intë¡œ ë°”ê¿¨ë‹¤. ê·¸ ë¶€ë¶„ì„ ë°”ê¿¨ë”ë‹ˆ í•´ê²°í•  ìˆ˜ ìˆì—ˆë‹¤.

---

- 4 æ—¥

# 2021 ì¹´ì¹´ì˜¤ ì¶”ì²œíŒ€ ë´„ ì¸í„´ ì½”ë”©í…ŒìŠ¤íŠ¸

ê²°ë¡ ë¶€í„° ë§í•˜ìë©´ ë§í–ˆë‹¤. í•´ì»¤ë­í¬ë¡œ ì§„í–‰ë˜ë©° ì´ 5ë¬¸ì œê°€ ë‚˜ì™”ë‹¤.

rest api ë¬¸ì œ 1ê°œ, ê°ê´€ì‹ 1ê°œ, ps ë¬¸ì œ 3ê°œê°€ ë‚˜ì™”ëŠ”ë° ë„ˆë¬´ ì–´ë µê²Œ ìƒê°í–ˆë‹¤. ìƒê°ë³´ë‹¤ ì‰½ê²Œ í’€ ìˆ˜ ìˆëŠ” ë¬¸ì œê°€ ìˆì—ˆëŠ”ë° ë¬¸ì œë¥¼ ëê¹Œì§€ ë‹¤ ì½ì§€ ì•Šê³  input ìœ„ì£¼ë¡œ í•´ê²°í•˜ë ¤í•˜ë‹¤ë³´ë‹ˆ ë„ˆë¬´ ì–´ë µê²Œ ì ‘ê·¼í–ˆë‹¤. ë˜í•œ, ëª¨ë“  í’€ì´ì—ì„œ 2% ë¶€ì¡±í–ˆë‹¤. ë§Œì•½ ë¬¸ì œë¥¼ ë” ì½ê³  í•˜ë‚˜í•˜ë‚˜ ì²œì²œíˆ ì ‘ê·¼í–ˆë‹¤ë©´ ê²°ê³¼ëŠ” ë‹¬ëì„ ê²ƒ ê°™ë‹¤. ê·¸ë¦¬ë”” 1ë¬¸ì œ, ê·¸ë˜í”„ 1ë¬¸ì œ, êµ¬í˜„ 1ë¬¸ì œë¼ ìƒê°ëœë‹¤.

ì§€ê¸ˆ ìƒê°í•˜ë©´ 1ë¬¸ì œ ì œì™¸í•˜ê³ ëŠ” ì‹œê°„ ë‚´ì— í•´ê²°í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤. ì§€ì‹ê³¼ ê²½í—˜ì´ ë¶€ì¡±í•´ì„œ ì›í•˜ëŠ” ë§Œí¼ í•´ê²°í•˜ì§€ ëª»í•œ ê²½í—˜ì„ í•  ìˆ˜ ìˆì—ˆë‹¤. ë‹¤ìŒì—ë„ ì´ëŸ¬í•œ ë‚´ìš©ì´ ë‚˜ì˜¬ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì¡°ê¸ˆ ë” ì—´ì‹¬íˆ ê³µë¶€í•´ì„œ ë„ì „í•´ì•¼ê² ë‹¤.

---

- 5 æ—¥

# Absoulte Path & Canonical Path

- ë ˆí¼ëŸ°ìŠ¤: [absolute-path-vs-canonical-path](https://www.benjaminlog.com/entry/absolute-path-vs-canonical-path)

ìœ ë‹‰ìŠ¤ ì‹œìŠ¤í…œì—ì„œ ì‚¬ìš©í•˜ëŠ” ê²½ë¡œ ì¤‘ ì ˆëŒ€ ê²½ë¡œì— ëŒ€í•´ì„œëŠ” í”„ë¡œê·¸ë˜ë°ì„ í•˜ë©´ ë§ì´ ì ‘í•´ë³¼ ìƒì‹ì´ë‹¤. í•˜ì§€ë§Œ canonical pathì— ëŒ€í•´ì„œëŠ” ì ‘í•´ë³´ì§€ ëª»í–ˆëŠ”ë° ìœ„ì˜ ê¸€ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì„¤ëª…í•œë‹¤.

> Canonical PathëŠ” ì–´ë–¤ íŒŒì¼ì˜ ê²½ë¡œë¥¼ ë‚˜íƒ€ë‚´ê¸° ìœ„í•œ ìœ ì¼í•œ ì‹¬ë³¼ì´ë‹¤. ë˜í•œ Canonical pathëŠ” í•­ìƒ ì ˆëŒ€ê²½ë¡œì´ê¸°ë„ í•˜ë‹¤. ë¬¼ë¡  ì—­ì€ ì„±ë¦½í•˜ì§€ ì•ŠëŠ”ë‹¤.

ì—¬ê¸°ì„œ absoulte pathì™€ ë¹„êµë¥¼ í•˜ë©´ì„œ ì„¤ëª…ì„ ë”í•´ë³´ì.

`/origin/file1`ê³¼ `/origin/../origin/file1`ì˜ absoulte pathëŠ” ë‹¤ë¥¼ê¹Œ?

ë‘˜ ë‹¤ absoulte pathë¼ê³  í•  ìˆ˜ ìˆë‹¤. ì¦‰, ë§ì€ ìˆ˜ì˜ absoulte pathëŠ” ë§Œë“¤ì–´ì§ˆ ìˆ˜ ìˆë‹¤.

í•˜ì§€ë§Œ canonical pathëŠ” ì„¤ëª…í•œ ë°”ì™€ ê°™ì´ ìœ ì¼í•œ ê²½ë¡œë¥¼ ê°€ì§„ë‹¤. ì—¬ê¸°ì„œëŠ” `/origin/file1` ì´ í•œ ê²½ë¡œë§Œì´ canonical pathë¼ê³  í•  ìˆ˜ ìˆë‹¤.

---

# PS

LeetCodeì—ì„œ ë§¤ë‹¬ ì§„í–‰í•˜ëŠ” LeetCoding Challengeë¥¼ ê³„ì† ì°¸ì—¬í•˜ë ¤ê³  í•œë‹¤. ì €ë²ˆì— ë³¸ ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œ ëŠë‚€ ì ì€ ì˜ì–´ ë¬¸ì œì— ëŒ€í•´ì„œ ì¡°ê±´ê³¼ ëª©í‘œë¥¼ íŒŒì•…í•˜ëŠ” ë¶€ë¶„ì´ ë„ˆë¬´ ëŠë¦¬ê¸° ë•Œë¬¸ì— ì˜ì–´ ë¬¸ì œì— ëŒ€í•´ ë§ì´ ì ‘í•´ë³¼ë ¤ê³  í•˜ë©°, í•˜ë£¨ì— í•œ ë¬¸ì œëŠ” ê¼­ í‘¸ëŠ” ë°©í–¥ìœ¼ë¡œ ë‚˜ì•„ê°ˆ ê²ƒì´ë‹¤.

- Simpliy Path

```cpp
class Solution {
public:
    string simplifyPath(string path) {
        vector<string> v;
        string temp, ans;
        for(int i=0; i<path.length(); i++) {
            if(path[i] == '/') {
                if(temp == ".") {
                    temp.clear();
                    continue;
                }
                else if(temp == "..") {
                    if(v.size())
                        v.pop_back();
                }
                else if(!temp.empty()) {
                    v.push_back(temp);
                }
                temp.clear();
            } else {
                temp += path[i];
            }
        }
        if(path[path.length()-1] != '/') {
            if(temp == "..") {
                if(v.size())
                    v.pop_back();
            }
            else if(!temp.empty() && temp != ".") {
                v.push_back(temp);
            }
        }
        for (int i=0; i<v.size(); i++)
            ans += '/' + v[i];

        if(ans.empty())
            ans = '/';

		return ans;
    }
};
```

ì£¼ì–´ì§„ absolute pathë¥¼ canonical pathë¡œ ë°”ê¿”ì•¼í•˜ëŠ” ë¬¸ì œì´ë‹¤. ë”°ë¼ì„œ `.`ì€ ë¬´ì‹œí•˜ë©° `..`ì˜ ì—­í• ë§Œ ì£¼ì–´ì§„ ì±„ë¡œ êµ¬í˜„í•˜ì˜€ë‹¤. ì´ ë•Œ `/`ë¥¼ í†µí•´ì„œ ì§€ê¸ˆê¹Œì§€ ë“¤ì–´ì˜¨ ë¬¸ìì—´ì„ ë²¡í„°ì— ë„£ì–´ì„œ ê´€ë¦¬í•´ì£¼ì—ˆë‹¤. ë§ˆì§€ë§‰ì—ëŠ” `/`ê°€ ë‚˜ì˜¬ ìˆ˜ë„ ìˆê³  ì•ˆ ë‚˜ì˜¬ ìˆ˜ë„ ìˆë‹¤. ë”°ë¼ì„œ ë§Œì•½ ë§ˆì§€ë§‰ ê°’ì´ `/`ê°€ ì•„ë‹ˆë¼ë©´ í¬ë¬¸ ë‚´ì—ì„œ ì‚¬ìš©í•œ ë…¼ë¦¬ ê·¸ëŒ€ë¡œ ì´ì–´ì„œ ì‚¬ìš©í•´ì£¼ì—ˆë‹¤. ë²¡í„° ì›ì†Œ ê°’ ì•ì— `/`ë¥¼ ë¶™ì—¬ì„œ ë°˜í™˜í•´ì£¼ë©´ ë§ˆë¬´ë¦¬ê°€ ëœë‹¤.

---

- 6 æ—¥

# PS

LeetCode

- Binary Tree Right Side View

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
	void rightSideViewFunc(TreeNode *root, int level, int *maxLevel, vector<int> &v) {
		if(root == NULL)
			return;

		if(*maxLevel < level) {
			v.push_back(root->val);
			*maxLevel = level;
		}

		rightSideViewFunc(root->right, level + 1, maxLevel, v);
		rightSideViewFunc(root->left, level + 1, maxLevel, v);
	}

    vector<int> rightSideView(TreeNode* root) {
        vector<int> v;
        int maxLevel = 0;
        rightSideViewFunc(root, 1, &maxLevel, v);
        return v;
    }
};
```

ì´ì§„íŠ¸ë¦¬ê°€ ì£¼ì–´ì¡Œì„ ë•Œ ê°€ì¥ ì˜¤ë¥¸ìª½ì— ìˆëŠ” ë…¸ë“œë¥¼ ì¶œë ¥í•˜ëŠ” ë¬¸ì œì´ë‹¤. ì£¼ì–´ì§„ êµ¬ì¡°ì²´ë¥¼ ì´ìš©í•˜ë©´ì„œ í•¨ìˆ˜ë¥¼ ì™„ì„±ì‹œì¼œì•¼ í•˜ë¯€ë¡œ DFSì™€ ê°™ì´ êµ¬í˜„í•˜ì˜€ë‹¤. ê° levelì„ ë³´ë©´ì„œ í•´ë‹¹ ì¸µì—ì„œ ê°€ì¥ ë¨¼ì € ì ‘í•˜ëŠ” ê°’ì„ ë²¡í„°ì— ë„£ì–´ì„œ ë°˜í™˜í•˜ë„ë¡ í•˜ì˜€ë‹¤. ì´ê²ƒì´ ê°€ëŠ¥í•œ ì´ìœ ëŠ” í•¨ìˆ˜ì—ì„œ ì œì¼ ë¨¼ì € ë£¨íŠ¸ì˜ ì˜¤ë¥¸ìª½ì„ ë¨¼ì € íƒìƒ‰í•˜ë„ë¡ í•˜ì˜€ê¸° ë•Œë¬¸ì´ë‹¤.

ë‹¤ë¥¸ ì‚¬ëŒë“¤ì˜ ì½”ë“œë¥¼ ë³´ë‹¤ê°€ íš¨ìœ¨ì´ ë§¤ìš° ì¢‹ì€ ì½”ë“œë¥¼ ë³´ê²Œ ë˜ì–´ì„œ ê°™ì´ ì˜¬ë¦°ë‹¤.

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> ans;
        if(root==NULL)
            return ans;
        queue<TreeNode*> q;
        q.push(root);
        int i;
        while(!q.empty())
        {
            int n=q.size();
            for(i=0;i<n;i++)
            {
                TreeNode* temp=q.front();
                q.pop();
                if(temp->left)
                    q.push(temp->left);
                if(temp->right)
                    q.push(temp->right);
                if(i==n-1)
                    ans.push_back(temp->val);
            }
        }
        return ans;
    }
};
```

ì´ì§„íŠ¸ë¦¬ì˜ ê° ì¸µì˜ ì˜¤ë¥¸ìª½ ë…¸ë“œë“¤ì„ ì–»ê¸° ìœ„í•´ì„œ ë‚´ê°€ í–ˆë˜ ë°©ì‹ê³¼ëŠ” ë‹¬ë¦¬ íë¥¼ ì´ìš©í•œ ë°©ë²•ìœ¼ë¡œ whileë¬¸ì´ í•œë²ˆ ëë‚  ë•Œë§ˆë‹¤ ì´ì§„íŠ¸ë¦¬ì˜ í•œ ì¸µì´ ëë‚˜ëŠ” ê²ƒì´ë‹¤. ë”°ë¼ì„œ íì—ëŠ” í˜„ì¬ ì¸µì˜ ë…¸ë“œë“¤ì´ ë“¤ì–´ìˆìœ¼ë©°, ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ì˜ ìì‹ ë…¸ë“œë“¤ì„ íì— ì§‘ì–´ ë„£ê²Œ ëœë‹¤. ì²˜ìŒì— íì˜ í¬ê¸°ë§Œí¼ í¬ë¬¸ì„ êµ¬ì„±í•˜ì—¬ í•œ ì¸µì—ì„œë§Œ ëŒê²Œ í•˜ì˜€ëŠ”ë° ì´ ë•Œ, í¬ë¬¸ì˜ ë§ˆì§€ë§‰ ë°˜ë³µì—ëŠ” ë¬´ì¡°ê±´ í•´ë‹¹ ì¸µì˜ ì˜¤ë¥¸ìª½ ë…¸ë“œê°€ ì˜¤ê²Œ ëœë‹¤. ë”°ë¼ì„œ í•´ë‹¹ ë…¸ë“œë¥¼ ëª¨ì•„ì„œ ë°˜í™˜í•´ì£¼ë©´ ëœë‹¤.

ì´ì§„íŠ¸ë¦¬ì— ëŒ€í•´ì„œ ê³µë¶€í•  ë•Œ, ê°•ì˜ì™€ ì±…ì„ ë³´ê³  ë°°ìš´ ê²ƒì„ ì´ìš©í•˜ì—¬ í’€ì—ˆë‹¤. ë‚´ê°€ í‘¼ í’€ì´ë„ ì„±ëŠ¥ ë©´ì—ì„œëŠ” ë‚˜ì˜ì§€ëŠ” ì•Šë‹¤. í•˜ì§€ë§Œ, ê°™ì€ ìƒê°ì„ ì„ íƒí•œ ì»¨í…Œì´ë„ˆì— ë”°ë¼ì„œ ì„±ëŠ¥ì´ í™•ì‹¤íˆ ë‹¬ë¼ì§€ë¯€ë¡œ ì„ íƒí•  ìˆ˜ ìˆëŠ” í­ì„ ë„“í˜€ì•¼ê² ë‹¤. íë¡œ í‘¼ í’€ì´ëŠ” ë‚´ê°€ ìƒê°í•˜ê¸°ì—ëŠ” ì •ë§ ì¢‹ì€ í’€ì´ë¼ê³  ìƒê°ëœë‹¤.

---

- 7 æ—¥

# PS

- Shortest Distance to a Character

```cpp
class Solution {
public:
    vector<int> shortestToChar(string s, char c) {
        vector<int> v, ans;
        for (int i=0; i<s.length(); i++) {
            if(s[i] == c) {
                v.push_back(i);
            }
        }
        int idx= 0;
        for (int i=0; i<s.length(); i++) {
            if(idx != v.size()-1) {
                if(abs(v[idx]-i) >= abs(v[idx+1]-i)) {
                    idx++;
                }
            }
            ans.push_back(abs(i-v[idx]));
        }
        return ans;
    }
};
```

ë¬¸ìì—´ê³¼ íŠ¹ì •í•œ ë¬¸ìê°€ ì£¼ì–´ì¡Œì„ ë•Œ ë¬¸ìì—´ ì†ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ íŠ¹ì •í•œ ë¬¸ìì˜ ê±°ë¦¬ë¥¼ ë¬¸ìë§ˆë‹¤ êµ¬í•´ì„œ ë°˜í™˜í•˜ëŠ” ë¬¸ì œì´ë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ `nicemeetyou`ê°€ ì£¼ì–´ì¡Œì„ ë•Œ ë¬¸ìëŠ” `e`ë¼ê³  ê°€ì •í•œë‹¤. ê·¸ë ‡ë‹¤ë©´ ì›í•˜ëŠ” ì •ë‹µ ë°°ì—´ì€ `32101001234`ì´ë‹¤.

ë¨¼ì € íŠ¹ì •í•œ ë¬¸ìê°€ ë¬¸ìì—´ì— ì–´ë–¤ ì¸ë±ìŠ¤ì— ìœ„ì¹˜í•´ìˆëŠ”ì§€ êµ¬í•œë‹¤. ê·¸ë ‡ê²Œë˜ë©´ ë¬¸ìì—´ì—ì„œ ëª‡ë²ˆì§¸ ì¸ë±ìŠ¤ì—ì„œ íŠ¹ì •í•œ ë¬¸ìê°€ ë‚˜ì˜¤ëŠ”ì§€ ì•Œê³  ìˆë‹¤. ë”°ë¼ì„œ ë¬¸ìì—´ ì¸ë±ìŠ¤ì—ì„œ íŠ¹ì •í•œ ë¬¸ìê°€ ë“¤ì–´ìˆëŠ” ì¸ë±ìŠ¤ë¥¼ ë¹¼ ì¤€ ê±°ë¦¿ê°’ ë§Œí¼ì„ ì¶œë ¥í•˜ë©´ ëœë‹¤. ì´ ë•Œ, ê°€ì¥ ê°€ê¹Œìš´ íŠ¹ì •í•œ ë¬¸ìë¥¼ ì°¾ì•„ì•¼í•˜ë¯€ë¡œ í˜„ì¬ ì¸ë±ìŠ¤ì™€ ë‹¤ìŒ ì¸ë±ìŠ¤ ì¤‘ ê°€ê¹Œìš´ ê²ƒì„ ì·¨í•´ì„œ ë¹¼ì¤˜ì•¼í•œë‹¤.

- ì—¬í–‰ê²½ë¡œ

```cpp
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

const int MAX = 1e5+1;

bool visited[MAX];
string ans = "abc";

void dfs(vector<vector<string>> &tickets, string from, string path, int level) {
    if(level == tickets.size()) {
        if(path < ans)
        	ans = path;
        return;
    }

    for (int i=0; i<tickets.size(); i++) {
        if(tickets[i][0] == from && !visited[i]) {
            visited[i] = true;
            dfs(tickets, tickets[i][1], path + tickets[i][1], level+1);
            visited[i] = false;
        }
    }
}

vector<string> solution(vector<vector<string>> tickets) {
    vector<string> answer, temp;
    string start = "ICN";
    sort(tickets.begin(), tickets.end());

    dfs(tickets, start, start, 0);

    for(int i=0; i<ans.length(); i+=3) {
        answer.push_back(ans.substr(i,3));
    }
    return answer;
}
```

DFS ë¬¸ì œë¡œ, ëª¨ë“  ì—¬í–‰ì§€ë¥¼ ë‹¤ ëŒ ìˆ˜ ìˆë‹¤ê³  ê°€ì •í•˜ê³  ì—¬í–‰ì§€ë“¤ì„ ê²½ìœ í•´ì„œ ëˆë‹¤. ì´ ë•Œ, ë„ëŠ” ìˆœì„œë¥¼ ì°¾ëŠ” ë¬¸ì œì´ë‹¤. ë”°ë¼ì„œ dfsë¥¼ í†µí•´ì„œ ì­ˆìš± ë”°ë¼ê°€ì„œ ì°¾ë˜, ë˜‘ê°™ì€ ë ˆë²¨ì˜ ì—¬í–‰ì§€ë¼ë©´ ì‚¬ì „ ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì–´ì•¼í•œë‹¤. ì •ë ¬ í›„ dfs í•¨ìˆ˜ë¥¼ í†µí•´ì„œ ëª¨ë“  ê°’ì„ êµ¬í•œë‹¤.

dfs í•¨ìˆ˜ì—ì„œëŠ” ëŒì•„ë³´ì§€ ì•Šì€ ì—¬í–‰ì§€ ì¤‘ ì¶œë°œ ì—¬í–‰ì§€ê°€ ê°™ë‹¤ë©´ dfs í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë©°, ì´ ì°¾ì€ ìˆ«ìê°€ ì£¼ì–´ì§„ í‹°ì¼“ê³¼ ê°™ë‹¤ë©´ ëª¨ë“  ì—¬í–‰ì§€ë¥¼ ê²½ìœ í•œ ê²ƒì´ë¯€ë¡œ í•´ë‹¹ ê°’ë“¤ ì¤‘ ê°€ì¥ ì‚¬ì „ì  ì •ì˜ê°€ ì•ì„œëŠ” ë¬¸ìì—´ì„ ê°€ì§€ê³  íŒŒì‹±í•˜ì—¬ ë°˜í™˜í•œë‹¤.

---

# í† ìµ

í† ìµì„ ì¹˜ë¤˜ëŠ”ë° ë‹¨ì§€ ì¡¸ì—…ì¡°ê±´ìœ¼ë¡œì¨ ì‘ì‹œí–ˆë‹¤. í•˜ì§€ë§Œ ì˜ì–´ ë ˆí¼ëŸ°ìŠ¤ë¥¼ ì½ëŠ” ì •ë„ë¼ê³  ìƒê°í–ˆì§€ë§Œ ìƒë‹¹íˆ ë¶€ì¡±í•œê±¸ ëŠê¼ˆë‹¤. ì˜ì–´ ë ˆí¼ëŸ°ìŠ¤ë¥¼ ì½ëŠ” ë‚ ì´ ë§ì•„ì§ˆí…Œë‹ˆ ì•ìœ¼ë¡œ ì¡°ê¸ˆì”© ì˜ì–´ ê³µë¶€ë¥¼ ì­‰ í•´ë‚˜ê°€ì•¼ê² ë‹¤.

---

- 8 æ—¥

# PS

- Peeking Iterator

```cpp
/*
 * Below is the interface for Iterator, which is already defined for you.
 * **DO NOT** modify the interface for Iterator.
 *
 *  class Iterator {
 *		struct Data;
 * 		Data* data;
 *		Iterator(const vector<int>& nums);
 * 		Iterator(const Iterator& iter);
 *
 * 		// Returns the next element in the iteration.
 *		int next();
 *
 *		// Returns true if the iteration has more elements.
 *		bool hasNext() const;
 *	};
 */

class PeekingIterator : public Iterator {
public:
	PeekingIterator(const vector<int>& nums) : Iterator(nums) {
	    // Initialize any member here.
	    // **DO NOT** save a copy of nums and manipulate it directly.
	    // You should only use the Iterator interface methods.

	}

    // Returns the next element in the iteration without advancing the iterator.
	int peek() {
        return Iterator(*this).next();
	}

	// hasNext() and next() should behave the same as in the Iterator interface.
	// Override them if needed.
	int next() {
        return Iterator::next();
	}

	bool hasNext() const {
        return Iterator::hasNext();
	}
};
```

Leetcode ì˜¤ëŠ˜ì˜ ë¬¸ì œë¡œ Iterator í´ë˜ìŠ¤ê°€ ì£¼ì–´ì§€ê³  ì´ í´ë˜ìŠ¤ë¥¼ ìƒì†í•˜ëŠ” PeekingIterator í´ë˜ìŠ¤ì˜ í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ì£¼ëŠ” ë¬¸ì œì´ë‹¤. ë¬¸ì œì—ì„œ ì—¬ëŸ¬ ê°€ì§€ ì¡°ê±´ì„ ì£¼ì„ì„ í†µí•´ì„œ ë„£ì–´ì£¼ì—ˆë‹¤. ë‚˜ëŠ” ìµœëŒ€í•œ ì§§ê³  ìˆëŠ” í•¨ìˆ˜ë¥¼ ì´ìš©í•˜ë ¤ê³  í•˜ì˜€ë‹¤. ë”°ë¼ì„œ nextì™€ hasNextëŠ” ìˆëŠ” í´ë˜ìŠ¤ì—ì„œ ê·¸ëŒ€ë¡œ í˜¸ì¶œí•˜ì˜€ê³  peekì˜ ê²½ìš°ì—ë§Œ í˜„ì¬ ê°ì²´ë¥¼ ìƒìœ„ í´ë˜ìŠ¤ì— ë§ì¶°ì„œ next í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ë‹¤ìŒ ì›ì†Œë§Œ ì•Œì•„ë³¼ ìˆ˜ ìˆê²Œ í•˜ì˜€ë‹¤.

- `2174. ë¡œë´‡ ì‹œë®¬ë ˆì´ì…˜`

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX = 100 + 2;

int board[MAX][MAX];

int px[4] = {-1, 0, 1, 0};
int py[4] = {0, 1, 0, -1};

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	int a, b, n, m;
	int robot = 0, wall = 0, crashRobot = 0;
	cin >> a >> b >> n >> m;
	vector<pair<pair<int,int>, int>> v;
	v.push_back({{0,0}, 0});
	for (int i=1; i<=n; i++) {
		int y, x, intDir;
		char dir;
		cin >> x >> y >> dir;
		if(dir == 'N')
			intDir = 1;
		else if (dir == 'E')
			intDir = 2;
		else if (dir == 'S')
			intDir = 3;
		else
			intDir = 0;
		v.push_back({{x,y},intDir});
		board[x][y] = i;
	}

	for (int i=0; i<m; i++) {
		int num, repeat;
		char cmd;

		cin >> num >> cmd >> repeat;

		if(wall || robot)
			continue;

		int dx = v[num].first.first;
		int dy = v[num].first.second;
		int dir = v[num].second;
		while(repeat--) {

			if(cmd == 'F') {
				board[dx][dy] = 0;
				dx += px[dir];
				dy += py[dir];
				if(dy < 1 || dx < 1 || dy > b || dx > a) {
					wall = num;
					break;
				}
				if(board[dx][dy]) {
					robot = num;
					crashRobot = board[dx][dy];
					break;
				}
				board[dx][dy] = num;
				v[num] = {{dx, dy}, dir};
			}
			else if(cmd == 'R') {
				dir = (dir + 1) % 4;
				v[num] = {{dx, dy}, dir};
			}
			else if (cmd == 'L') {
				dir = (dir + 3) % 4;
				v[num] = {{dx, dy}, dir};
			}
		}
	}
	if(wall)
		cout << "Robot " << wall << " crashes into the wall";
	else if(robot)
		cout << "Robot " << robot << " crashes into robot " << crashRobot;
	else
		cout << "OK";
}
```

ì¢Œí‘œê³„ê°€ ì¡°ê¸ˆ ë‹¤ë¥´ë‹¤ëŠ”ê±°ë§Œ ë¹¼ë©´ ì²œì²œíˆ êµ¬í˜„í•´ë‚˜ê°€ë©´ ëœë‹¤. yì¶•ì´ ë°˜ëŒ€ë¡œ ë˜ì–´ìˆë‹¤ëŠ” ê²ƒì„ ì´ìš©í•´ì„œ ì¢Œí‘œê³„ë¥¼ ëˆ•í˜€ì„œ ìƒê°í–ˆë‹¤. ë”°ë¼ì„œ ì›ë˜ ì´ì°¨ì› ë°°ì—´ì„ ì‚¬ìš©í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ì¢Œí‘œì¸ `arr[y][x]`ë¥¼ `arr[x][y]`ë¡œ ë°”ê¿”ì„œ ì´ìš©í•˜ì˜€ê³  ë°©í–¥ì— ë”°ë¥¸ ì›€ì§ì„ë„ ê·¸ëŸ¬í•˜ê²Œ 90ë„ í‹€ì—ˆë‹¤. ì´í›„ì—ëŠ” ë²½ì— ë¶€ë”ªíˆëŠ” ê²ƒê³¼ ë¡œë´‡ ë¼ë¦¬ ë§Œë‚˜ëŠ” ê²ƒì„ êµ¬í˜„í•´ì£¼ê¸°, ë°©í–¥ í‹€ê¸°ë§Œ êµ¬í˜„í•´ì£¼ì—ˆë‹¤.

---

- 9 æ—¥

# PS

- Convert BST to Greater Tree

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void inorder(TreeNode* root, vector<int*>& nums) {
        if(root != nullptr) {
            inorder(root->left, nums);
            nums.push_back(&root->val);
            inorder(root->right, nums);
        }
    }
    TreeNode* convertBST(TreeNode* root) {
        vector<int*> nums;
        inorder(root, nums);

        for (int i=nums.size()-1; i>0; i--) {
            *nums[i-1] += *nums[i];
        }
        return root;
    }
};
```

- [leetcode](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/)

ê°™ì€ ë¬¸ì œë¡œ ì£¼ì†Œë¥¼ ë‹¬ì•˜ë‹¤.

![ì˜ˆì‹œ](https://assets.leetcode.com/uploads/2019/05/02/tree.png)

ì˜ˆì œ ì‚¬ì§„ê³¼ ê°™ì´ ì˜¤ë¥¸ìª½ ìì‹íŠ¸ë¦¬ -> ë£¨íŠ¸ -> ì™¼ìª½ ìì‹íŠ¸ë¦¬ì˜ ê°’ì„ ê²½ë¡œì— ë”°ë¼ ë”í•´ì„œ ê·¸ëŒ€ë¡œ ë°˜í™˜í•´ì£¼ë©´ ë˜ëŠ” ë¬¸ì œì´ë‹¤.

ë¬¸ì œì—ì„œëŠ” ì˜¤ë¥¸ìª½ë¶€í„° ì‹œì‘í•˜ëŠ” ê²ƒìœ¼ë¡œ ë³´ì´ë‚˜, ê²°êµ­ì—ëŠ” ì™¼ìª½ ìì‹ë“¤ì˜ ê°’ì´ ë‹¤ ë”í•œ ê°’ì´ ë˜ë¯€ë¡œ, íŠ¸ë¦¬ ìˆœíšŒì¤‘ ì¤‘ìœ„ ìˆœíšŒë¥¼ ì´ìš©í•˜ì—¬ ìˆœì„œë¥¼ ì¢Œ->ë£¨íŠ¸->ìš°ë¡œ ë§Œë“¤ ìˆ˜ ìˆë‹¤ë©´ ë§¤ìš° í¸í•˜ê²Œ í’€ ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤.

ë”°ë¼ì„œ ì¤‘ìœ„ ìˆœíšŒë¥¼ ì´ìš©í•˜ì—¬ ë²¡í„°ì— ê°’ì„ ë„£ì–´ì£¼ë©°, ë²¡í„°ì˜ ì¸ë±ìŠ¤ë¡œ ì ‘ê·¼í•  ìˆ˜ ìˆê²Œ ì •ìˆ˜ì˜ ì£¼ì†Œê°’ì„ ìë£Œí˜•ìœ¼ë¡œ ì‚¼ì•˜ë‹¤. ì´í›„ì—ëŠ” ì¤‘ìœ„ìˆœíšŒì˜ ìˆœì„œë¥¼ ë°˜ëŒ€ë¡œ ê°’ì„ ë”í•´ê°€ë©´ nums[0]ì—ëŠ” ìµœì¢…ì ìœ¼ë¡œ ëª¨ë“  ê°’ì˜ í•©ì´ ë‹´ê¸°ê²Œ ë˜ë©°, ê·¸ ê²½ë¡œì˜ ê°’ë“¤ ë˜í•œ ì˜ ë”í•´ì§„ë‹¤.

---

# ê°ì²´ì§€í–¥ì˜ ì‚¬ì‹¤ê³¼ ì˜¤í•´

ì´ë²ˆ ì„¤ ì—°íœ´ë¥¼ ì´ìš©í•˜ì—¬ ì‚¬ë†“ê³  ì ì‹œ ìŠí˜€ì¡Œë˜ ì±…ì„ ì½ì–´ë³¼ë ¤ê³  í•œë‹¤. ë°”ë¡œ, ê°ì²´ì§€í–¥ì˜ ì‚¬ì‹¤ê³¼ ì˜¤í•´ë¼ëŠ” ì±…ì´ë‹¤. ì´ ì±…ì€ ì‚¬ëŒë“¤ì´ ê°ì²´ì§€í–¥ì´ë¼ëŠ” íŒ¨ëŸ¬ë‹¤ì„ì— ëŒ€í•´ì„œ í”íˆ ê°€ì§€ê²Œ ë˜ëŠ” ì˜¤í•´ì™€ ìƒê°ë“¤ì„ ì´í•´í•˜ê¸° ì‰½ê²Œ ì •ë¦¬í•´ì¤€ë‹¤.

## ê°ì²´ì™€ í´ë˜ìŠ¤

ê·¸ ì¤‘ í•˜ë‚˜ëŠ” ë°”ë¡œ ê°ì²´ì§€í–¥ì„ ìƒê°í•  ë•Œ í•µì‹¬ì„ í´ë˜ìŠ¤ë¡œ ìƒê°í•˜ê²Œ ë˜ëŠ”ë° ê°ì²´ì§€í–¥ì— ìˆì–´ì„œ í•µì‹¬ì€ í´ë˜ìŠ¤ê°€ ì•„ë‹Œ ì ì ˆí•œ ì±…ì„ì„ ìˆ˜í–‰í•˜ëŠ” ì—­í• ê°„ì˜ ìœ ì—°í•˜ê³  ê²¬ê³ í•œ í˜‘ë ¥ê´€ê³„ë¥¼ êµ¬ì¶•í•˜ëŠ” ê²ƒì´ë‹¤. í´ë˜ìŠ¤ëŠ” ë‹¨ì§€ í˜‘ë ¥í•˜ëŠ” ê°ì²´ë¥¼ ë§Œë“¤ ë•Œ í•„ìš”í•œ êµ¬í˜„ ë§¤ì»¤ë‹ˆì¦˜ì¼ ë¿ì´ë¼ëŠ” ê²ƒì´ë‹¤. í´ë˜ìŠ¤ê°€ ì¤‘ìš”í•˜ì§€ ì•Šì€ ê²ƒì´ ì•„ë‹ˆë¼ ì‚¬ëŒë“¤ì´ í•µì‹¬ì„ ì˜ëª» ì•Œê³  ìˆë‹¤ëŠ” ì ì„ ì§€ì í•´ì¤€ë‹¤.

ë‚˜ëŠ” ê°ì²´ì§€í–¥ì— ëŒ€í•´ì„œ ë°°ìš¸ ë•Œ C++ê³¼ Javaë¥¼ ì´ìš©í•´ì„œ í´ë˜ìŠ¤ë¥¼ êµ¬ì¶•í•˜ê³  ìº¡ìŠí™”, ë‹¤í˜•ì„± ë“± ì—¬ëŸ¬ê°€ì§€ ìš©ì–´ì— ëŒ€í•´ì„œ ë°°ì› ë‹¤. í•˜ì§€ë§Œ ì±…ì˜ í•„ìëŠ” ê·¸ê²ƒë“¤ì´ ì¤‘ìš”í•œ ê²ƒì´ ì•„ë‹ˆë¼ê³  ì–˜ê¸°í•œë‹¤. ì¦‰, ë‹¤ë¥¸ ê²ƒë“¤ì€ êµ¬í˜„í•˜ê¸° ìœ„í•œ ìˆ˜ë‹¨ì¼ ë¿ì´ê³  ê°ì²´ì§€í–¥ì˜ ëª©ì ê³¼ í•µì‹¬ì„ ì •í™•íˆ ìƒê°í•˜ë¼ëŠ” ê²ƒì´ë‹¤.

> í´ë˜ìŠ¤ì˜ êµ¬ì¡°ë‚˜ ë©”ì„œë“œê°€ ì•„ë‹Œ ê°ì²´ì˜ ì—­í• , ì±…ì„, í˜‘ë ¥ì— ì§‘ì¤‘í•˜ë¼. ê°ì²´ì§€í–¥ì€ í´ë˜ìŠ¤ ì§€í–¥ì´ ì•„ë‹Œ ê°ì²´ ì§€í–¥ì´ë‹¤.

ì‹¤ìƒí™œê³¼ ë¹—ëŒ€ì–´ì„œ ê°ì²´ì— ëŒ€í•´ ì„¤ëª…í•˜ëŠ”ë° ë§ì€ ìƒê°ì„ í•˜ê²Œ í•˜ì˜€ë‹¤. í´ë˜ìŠ¤ë¥¼ êµ¬í˜„í•˜ê³  ê·¸ê±¸ í† ëŒ€ë¡œ ê°ì²´ì§€í–¥ í”„ë¡œê·¸ë˜ë°ì„ í–ˆë‹¤ê³  ìƒê°í•˜ì˜€ê³  í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•¨ì„ì¨ ë‚˜ëŠ” ê°ì²´ì§€í–¥ì„ ë°°ì› ë‹¤ê³  ìƒê°í–ˆë‹¤. í•˜ì§€ë§Œ ì´ ì±…ì€ ëª‡ ì¥ ì½ì§€ ì•Šì•˜ëŠ”ë° ê·¸ ë¶€ë¶„ì´ ì˜¤í•´ì˜€ë‹¤ê³  ë§í•˜ë‹ˆ ë‹¤ìŒì— ì´ì•¼ê¸°í•  ë‚´ìš©ì´ ë¬´ì—‡ì¸ì§€ ê¶ê¸ˆí•´ì§„ë‹¤.

---

- 10 æ—¥

# PS

- Copy List With Random Pointer

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;

    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {
    	if(head == nullptr)
    		return head;

        Node* original = head;
        while(original != nullptr) {
        	Node* copyNode = new Node(original->val);
        	copyNode->next = original->next;

        	original->next = copyNode;
        	original = copyNode->next;
		}

		original = head;

		while(original != nullptr) {
			if(original->random != nullptr) {
				original->next->random = original->random->next;
			}
			original = original->next->next;
		}

		original = head;
		Node* answer = head->next;
		Node* temp = answer;
		while(original != nullptr) {
			original->next = original->next->next;
			if(original->next != nullptr) {
				temp->next = original->next->next;
			}
			original = original->next;
			temp = temp->next;
		}
		return answer;
    }
};
```

ê¹Šì€ ë³µì‚¬ë¥¼ í†µí•´ì„œ ìƒˆë¡œìš´ ì£¼ì†Œë¥¼ ê°–ëŠ” ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ì–´ì•¼í•œë‹¤. ë”°ë¼ì„œ ì‚¬ì´íŠ¸ì—ì„œ íŒíŠ¸ì—ì„œ ë§í•˜ëŠ” `A -> B -> C -> D`ë¼ë©´ `A -> A' -> B -> B' -> C -> C' -> D -> D'`ë¡œ ìƒˆë¡œ ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•œ ë‹¤ìŒ `A' -> B' -> C' -> D'`ë¡œ ì—°ê²°í•˜ë„ë¡ ë§Œë“¤ì–´ì„œ ë°˜í™˜í•˜ëŠ”ê²Œ ë¬¸ì œì˜ ë‹µì´ë‹¤. randomê³¼ next ë¶€ë¶„ì„ í•´ë‹¹ ê¸¸ê²Œ ë‘” ë¦¬ìŠ¤íŠ¸ë¥¼ ì´ìš©í•´ì„œ í•´ê²°í•˜ë©´ ëœë‹¤.

---

# ê°ì²´ì§€í–¥ì˜ ì‚¬ì‹¤ê³¼ ì˜¤í•´

## ê°ì²´

ê°ì²´ì˜ ë‹¤ì–‘í•œ íŠ¹ì„±ì„ íš¨ê³¼ì ìœ¼ë¡œ ì„¤ëª…í•˜ê¸° ìœ„í•´ì„œëŠ” ìƒíƒœ, í–‰ë™, ì‹ë³„ìë¥¼ ì§€ë‹Œ ì‹¤ì²´ë¡œ ë³´ëŠ” ê²ƒì´ ê°€ì¥ íš¨ê³¼ì ì´ë‹¤ê³  í•œë‹¤.

### ìƒíƒœì™€ í”„ë¡œí¼í‹°

- ìƒíƒœë¥¼ ì´ìš©í•˜ë©´ ê³¼ê±°ì— ì–½ë§¤ì´ì§€ ì•Šê³  í˜„ì¬ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê°ì²´ì˜ í–‰ë™ ë°©ì‹ì„ ì´í•´í•  ìˆ˜ ìˆë‹¤.
- ê°ì²´ì˜ ìƒíƒœë¥¼ êµ¬ì„±í•˜ëŠ” ëª¨ë“  íŠ¹ì§•ì„ í”„ë¡œí¼í‹°ë¼ê³  í•œë‹¤. í”„ë¡œí¼í‹°ëŠ” ì •ì ì´ë‚˜, í”„ë¡œí¼í‹° ê°’ì€ ë™ì ì´ë‹¤.
- ê°ì²´ì™€ ê°ì²´ ì‚¬ì´ì˜ ì˜ë¯¸ìˆëŠ” ì—°ê²°ì¸ ë§í¬ê°€ ì¡´ì¬í•´ì•¼ ìš”ì²­ì„ ë°›ê³  ë³´ë‚¼ ìˆ˜ ìˆë‹¤.

### í–‰ë™

- í–‰ë™ì„ í†µí•´ ê°ì²´ ìì‹ ì˜ ìƒíƒœë¥¼ ë³€ê²½ì‹œí‚¨ë‹¤. ì´ í–‰ë™ì„ ë¶€ìˆ˜ íš¨ê³¼(side effect)ë¼ê³  í•œë‹¤.
  - ê°ì²´ ìì‹ ì˜ ìƒíƒœ ë³€ê²½
  - í–‰ë™ ë‚´ì—ì„œ í˜‘ë ¥í•˜ëŠ” ë‹¤ë¥¸ ê°ì²´ì— ëŒ€í•œ ë©”ì‹œì§€ ì „ì†¡
- í–‰ë™ì€ ê°ì²´ì˜ ìƒíƒœë¥¼ ë³€ê²½ì‹œí‚¤ì§€ë§Œ í–‰ë™ì˜ ê²°ê³¼ëŠ” ê°ì²´ì˜ ìƒíƒœì— ì˜ì¡´ì ì´ë‹¤.
  - ê°ì²´ì˜ í–‰ë™ì€ ìƒíƒœì— ì˜í–¥ì„ ë°›ëŠ”ë‹¤.
  - ê°ì²´ì˜ í–‰ë™ì€ ìƒíƒœë¥¼ ë³€ê²½ì‹œí‚¨ë‹¤.
- í–‰ë™ì„ ìƒíƒœë¥¼ ì´ìš©í•˜ì—¬ ë‘ ê°€ì§€ ê´€ì ìœ¼ë¡œ ì„œìˆ í•˜ë©´
  - ìƒí˜¸ì‘ìš©ì´ í˜„ì¬ì˜ ìƒíƒœì— ì–´ë–¤ ë°©ì‹ìœ¼ë¡œ ì˜ì¡´í•˜ëŠ”ê°€
  - ìƒí˜¸ì‘ìš©ì´ ì–´ë–»ê²Œ í˜„ì¬ì˜ ìƒíƒœë¥¼ ë³€ê²½ì‹œí‚¤ëŠ”ê°€

> í–‰ë™ì´ë€ ì™¸ë¶€ì˜ ìš”ì²­ ë˜ëŠ” ìˆ˜ì‹ ëœ ë©”ì‹œì§€ì— ì‘ë‹µí•˜ê¸° ìœ„í•´ ë™ì‘í•˜ê³  ë°˜ì‘í•˜ëŠ” í™œë™ì´ë‹¤. í–‰ë™ì˜ ê²°ê³¼ë¡œ ê°ì²´ëŠ” ìì‹ ì˜ ìƒíƒœë¥¼ ë³€ê²½í•˜ê±°ë‚˜ ë‹¤ë¥¸ ê°ì²´ì—ê²Œ ë©”ì‹œì§€ë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤. ê°ì²´ëŠ” í–‰ë™ì„ í†µí•´ ë‹¤ë¥¸ ê°ì²´ì™€ì˜ í˜‘ë ¥ì— ì°¸ì—¬í•˜ë¯€ë¡œ í–‰ë™ì€ ì™¸ë¶€ì— ê°€ì‹œì ì´ì–´ì•¼ í•œë‹¤.

### ìº¡ìŠí™”

ê°ì²´ê°„ì˜ ë©”ì‹œì§€ ì†¡ìˆ˜ì‹ ì‹œì— ì†¡ì‹ ìëŠ” ìˆ˜ì‹ ìì˜ ìƒíƒœ ë³€ê²½ì— ëŒ€í•´ì„œëŠ” ì•Œì§€ ëª»í•œë‹¤. ì¦‰, ê°ì²´ëŠ” ìƒíƒœë¥¼ ìº¡ìŠ ì•ˆì— ê°ì¶°ë‘” ì±„ ì™¸ë¶€ë¡œ ë…¸ì¶œí•˜ì§€ ì•ŠëŠ”ë‹¤. ì´ê²ƒì´ ìº¡ìŠí™”ê°€ ì˜ë¯¸í•˜ëŠ” ê²ƒì´ë‹¤. ì´ ë•Œ ì™¸ë¶€ì— ë…¸ì¶œë˜ëŠ” ê²ƒì€ í–‰ë™ ë¿ì´ë©°, ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ìœ ì¼í•œ ë°©ë²•ì´ë‹¤.

í–‰ë™ì„ ê²½ê³„ë¡œ ìº¡ìŠí™”í•˜ëŠ” ê²ƒì€ ê°ì²´ì˜ ììœ¨ì„±ì„ ë†’ì¸ë‹¤. ìŠ¤ìŠ¤ë¡œ íŒë‹¨í•˜ê³  ìŠ¤ìŠ¤ë¡œ ê²°ì •í•˜ëŠ” ê°ì²´ê°€ ììœ¨ì„±ì´ ë†’ì•„ì§ˆ ìˆ˜ë¡ ì§€ëŠ¥ì´ ë†’ì•„ì§„ë‹¤. í˜‘ë ¥í•˜ëŠ” ê°ì²´ë“¤ì˜ ì§€ëŠ¥ì´ ë†’ì•„ì§€ë©´ í˜‘ë ¥ì€ ìœ ì—°í•˜ê³  ê°„ê²°í•´ì§„ë‹¤.

> ìƒíƒœë¥¼ ì˜ ì •ì˜ëœ í–‰ë™ ì§‘í•© ë’¤ë¡œ ìº¡ìŠí™”í•˜ëŠ” ê²ƒì€ ê°ì²´ì˜ ììœ¨ì„±ì„ ë†’ì´ê³  í˜‘ë ¥ì„ ë‹¨ìˆœí•˜ê³  ìœ ì—°í•˜ê²Œ ë§Œë“ ë‹¤.

ì´ëŸ¬í•œ ë‚´ìš©ì´ ìƒíƒœë¥¼ ìº¡ìŠí™” í•´ì•¼í•˜ëŠ” ì´ìœ ì´ë‹¤.

---

- 11 æ—¥

# PS

- Valid Anagram

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        int alpha[26], dif[26];
        memset(alpha, 0, sizeof(alpha));
        memset(dif, 0, sizeof(dif));
        if(s.length() != t.length())
            return false;

        for (int i=0; i<s.length(); i++) {
            alpha[s[i] - 'a']++;
            dif[t[i] - 'a']++;
        }

        for (int i=0; i<26; i++) {
            if(alpha[i] != dif[i])
                return false;
        }

        return true;
    }
};
```

ë‘ ë¬¸ìì—´ì´ ì£¼ì–´ì¡Œì„ ë•Œ Anagramì¸ì§€ í™•ì¸í•˜ëŠ” ë¬¸ì œì´ë‹¤. ì²˜ìŒì—ëŠ” ì‰½ê²Œ í•´ê²°í•˜ê¸° ìœ„í•´ next_permutationì„ ì´ìš©í•´ì„œ ê°™ì€ ë¬¸ìì—´ì´ ìˆëŠ”ì§€ ì²´í¬í–ˆìœ¼ë‚˜ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì— ì—„ì²­ ê¸´ ë¬¸ìì—´ì´ ìˆì–´ì„œ ì‹œê°„ì´ˆê³¼ê°€ ë‚˜ì™”ë‹¤. ì´í›„ì—ëŠ” ì•ŒíŒŒë²³ ìˆ˜ë¥¼ ì„¼ ë’¤ ìˆ«ìê°€ ê°™ìœ¼ë©´ Anagramìœ¼ë¡œ íŒëª…í•˜ê³ , ë§Œì•½ ê¸¸ì´ê°€ ë‹¤ë¥´ë‹¤ë©´ ë¬¸ìì˜ ê°¯ìˆ˜ë„ ë‹¤ë¥´ê¸° ë•Œë¬¸ì— ê±°ì§“ì„ ë°˜í™˜í–ˆë‹¤.

- `2631. ì¤„ì„¸ìš°ê¸°`

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX = 200 + 1;

int arr[MAX];
int dp[MAX];

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	int n, ans = 0;
	cin >> n;
	for (int i=1; i<=n; i++) {
		cin >> arr[i];
	}

	for (int i=1; i<=n; i++) {
		dp[i] = 1;
		for (int j=1; j<=i; j++) {
			if(arr[j] < arr[i] && dp[i] < dp[j]+1) {
				dp[i] = dp[j] + 1;
			}
		}
		if(ans < dp[i])
			ans = dp[i];
	}
	cout << n - ans;
}
```

1 ~ nê¹Œì§€ì˜ ìˆ«ìê°€ ë¬´ì‘ìœ„ë¡œ ì£¼ì–´ì§ˆ ë•Œ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•˜ê¸° ìœ„í•œ ìµœì†Œì˜ ì›€ì§ì„ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤. ìµœì†Œì˜ ì›€ì§ì„ì„ ì•Œê¸° ìœ„í•´ì„œëŠ” LIS (ìµœì¥ ì¦ê°€ ë¶€ë¶„ ìˆ˜ì—´)ì„ êµ¬í•´ì•¼í•œë‹¤. ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•˜ê¸° ìœ„í•œ ìµœì†Œì˜ ì›€ì§ì„ì„ êµ¬í•´ì•¼í•˜ëŠ”ë° ì´ë¯¸ ì¦ê°€ ë¶€ë¶„ ìˆ˜ì—´ë¡œ ëœ ë¶€ë¶„ì€ ê±´ë“¤ì¼ í•„ìš”ê°€ ì—†ê¸° ë•Œë¬¸ì— ìµœì¥ ì¦ê°€ ë¶€ë¶„ ìˆ˜ì—´ í¬ê¸°ë¥¼ ì „ì²´ í¬ê¸°ì—ì„œ ëº€ ìˆ«ìê°€ ì •ë‹µì´ë‹¤.

ë”°ë¼ì„œ ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë°ì„ ì´ìš©í•˜ì—¬ ìµœì¥ ì¦ê°€ ë¶€ë¶„ ìˆ˜ì—´ì„ êµ¬í•œ ë’¤ ì „ì²´ í¬ê¸°ì—ì„œ ê·¸ í¬ê¸°ë¥¼ ë¹¼ì£¼ì—ˆë‹¤.

- `2170. ì„  ê¸‹ê¸°`

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	vector<pair<int,int>> v;
	int n, ans = 0;
	cin >> n;

	for (int i=0; i<n; i++) {
		int s, e;
		cin >> s >> e;
		v.push_back({s,e});
	}

	sort(v.begin(), v.end());

	int start = v[0].first;
	int end = v[0].second;

	for(int i=1; i<v.size(); i++) {
		if(v[i].first > end) {
			ans += end - start;
			start = v[i].first;
			end = v[i].second;
		}
		else if(v[i].first < end && end < v[i].second)
			end = v[i].second;
	}
	ans += end - start;

	cout << ans;
}
```

ë„í™”ì§€ì— ì„ ì„ ê¸‹ëŠ” ì¶œë°œì ê³¼ ë„ì°©ì ì´ ì£¼ì–´ì§€ê²Œ ë˜ëŠ”ë° ì´ ê°’ë“¤ì„ ê°€ì§€ê³  ì„ ì„ ê·¸ì€ ì´ ê¸¸ì´ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤. ì´ ë•Œ ê²¹ì¹˜ëŠ” ì„ ì€ í•˜ë‚˜ë¡œ ìƒê°í•´ì•¼í•œë‹¤.

ë”°ë¼ì„œ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë¨¼ì € ì‹œì‘ ì§€ì ì„ ê¸°ì¤€ìœ¼ë¡œ ì „ë¶€ ì •ë ¬ì„ í•œ ë‹¤ìŒ ì„ ì´ ê²¹ì¹˜ëŠ” ê²½ìš°ì™€ ì•ˆ ê²¹ì¹˜ëŠ” ê²½ìš°ë¡œ ë‚˜ëˆ„ì–´ì„œ í•´ê²°í•˜ì˜€ë‹¤. ë¨¼ì € ì•ˆ ê²¹ì¹˜ëŠ” ê²½ìš°ì—ëŠ” ì§€ê¸ˆê¹Œì§€ ê·¸ì€ ì„ ë“¤ì„ ë‹¤ ë”í•´ ê°’ì„ êµ¬í•œë‹¤. ê·¸ë¦¬ê³  ìƒˆë¡œ ì„ ì„ ì‹œì‘í•˜ê¸° ë•Œë¬¸ì— ì‹œì‘ ì§€ì ê³¼ ë„ì°© ì§€ì ì„ ë°”ê¿”ì¤€ë‹¤. ê²¹ì¹˜ëŠ” ê²½ìš°ì—ëŠ” ì‹œì‘ ì§€ì ì€ ê·¸ëŒ€ë¡œ ë‘ê³  ë„ì°© ì§€ì ì„ ê³„ì† ê°±ì‹ í•´ì¤€ë‹¤. ë§Œì•½ ê³„ì† ê²¹ì¹˜ê²Œ ê¸‹ë‹¤ê°€ ëë‚œë‹¤ë©´ ê°’ì„ ë”í•´ì£¼ì§€ ì•Šê¸° ë•Œë¬¸ì— ë§ˆì§€ë§‰ìœ¼ë¡œ ë„ì°© ì§€ì ì—ì„œ ì‹œì‘ ì§€ì ì„ ë¹¼ì„œ ê¸¸ì´ë¥¼ êµ¬í•´ì¤€ë‹¤.

---

- 12 æ—¥

# PS

- Number of Steps to Reduce a Number to Zero

```cpp
class Solution {
public:
    int numberOfSteps (int num) {
        int answer = 0;
        while(num) {
            if(num & 1)
                num--;
            else
                num /= 2;
            answer++;
        }
        return answer;
    }
};
```

Leetcode ì˜¤ëŠ˜ì˜ ë¬¸ì œëŠ” í™€ì§ ë‚˜ëˆ ì„œ ì§ìˆ˜ì¼ ë• 2ë¡œ ë‚˜ëˆ„ê³  í™€ìˆ˜ì¼ ë• 1ì„ ë¹¼ëŠ” ë°©ì‹ìœ¼ë¡œ ëª‡ë²ˆ ë°˜ë³µë˜ëŠ”ì§€ ì²´í¬í•˜ëŠ” ë¬¸ì œì˜€ë‹¤.

ì˜¤ëŠ˜ì€ í•´ì»¤ë­í¬ì—ì„œ ìë°”ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì´ìš©í•´ì„œ PS ë¬¸ì œë¥¼ í’€ì–´ë³´ì•˜ë‹¤. ì¡°ê¸ˆì´ë¼ë„ ìµìˆ™í•˜ê²Œ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œ ìë°”ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì´ìš©í–ˆì§€ë§Œ ì‰¬ìš´ ë‚œì´ë„ì˜ ë¬¸ì œë“¤ì´ë¼ì„œ ë¹ ë¥´ê²Œ í’€ì–´ë‚˜ê°”ë‹¤. ì´ì™¸ì—ë„ ìì£¼ ìë°”ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì´ìš©í•´ë´ì•¼ê² ë‹¤.

---

- 13 æ—¥

# PS

- Shortest Path in Binary Matrix

```cpp
class Solution {
private:
    int px[8] = {0, 1, 1, -1, -1, -1, 0, 1};
    int py[8] = {1, 0, 1, 1, 0, -1, -1, -1};
    bool visited[100][100];

public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        int size = grid.size();
        queue<pair<pair<int,int>,int>> q;
        if(!grid[0][0])
            q.push({{0,0}, 1});

        while(!q.empty()) {
            int y = q.front().first.first;
            int x = q.front().first.second;
            int cnt = q.front().second;
            q.pop();

            if(y == size-1 && x == size-1) {
                return cnt;
            }

            for(int i=0; i<8; i++) {
                int dy = y + py[i];
                int dx = x + px[i];

                if(dy < 0 || dx < 0 || dy >= size || dx >= size)
                    continue;
                if(grid[dy][dx] || visited[dy][dx])
                    continue;

                q.push({{dy,dx}, cnt+1});
                visited[dy][dx] = true;
            }
        }
        return -1;
    }
};
```

`n*n` í–‰ë ¬ì´ ìˆì„ ë•Œ `[0,0]`ì—ì„œ `[n-1,n-1]`ê¹Œì§€ ê°€ëŠ” ìµœì†Œ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œë¡œ, ë‹¨ìˆœí•œ 8ë°©í–¥ BFSë¬¸ì œì´ë‹¤. ë§Œì•½ ë¶ˆê°€ëŠ¥í•˜ë‹¤ë©´ -1ì„ ë¦¬í„´í•˜ê³  ì´ì™¸ì—ëŠ” ì œëŒ€ë¡œëœ ê±°ë¦¬ë¥¼ ë¦¬í„´í•´ì£¼ë©´ ëœë‹¤.

ë˜í•œ JSë¡œ í•´ì»¤ë­í¬ì—ì„œ ê³„ì†ì ìœ¼ë¡œ ë¬¸ì œ í’€ì´ë¥¼ í•˜ê³  ìˆë‹¤. í•˜ì§€ë§Œ ë‚¨ê¸¸ ì •ë„ì˜ ë‚œì´ë„ëŠ” ì•„ë‹ˆë¼ì„œ ê¸ˆë°©ê¸ˆë°© ë„˜ê¸°ê³  ìˆë‹¤. ë¯¸ë””ì›€ ì´ìƒë¶€í„°ëŠ” ê¸°ì–µì— ë‚¨ëŠ” ë‚´ìš©ì„ ê¸°ë¡í•˜ë ¤ê³  í•œë‹¤.

---

- 14 æ—¥

# PS

- Is Graph Bipartite?

```cpp
class Solution {
private:
    int visited[100];
    bool ansFlag;
public:
    void dfs(vector<vector<int>>& graph, int start, int color) {
        if(ansFlag || visited[start])
            return;

        visited[start] = color;

        for(int i=0; i<graph[start].size(); i++) {
            if(color == visited[graph[start][i]]) {
                ansFlag = true;
                return;
            }
            else if(!visited[graph[start][i]]) {
                if(color == 1)
                    dfs(graph, graph[start][i], 2);
                else
                    dfs(graph, graph[start][i], 1);
            }
        }
    }

    bool isBipartite(vector<vector<int>>& graph) {
        ansFlag = false;
        memset(visited, 0, sizeof(visited));
        for(int i=0; i<graph.size(); i++) {
            if(!visited[i])
                dfs(graph, i, 1);
        }

        return !ansFlag;
    }
};
```

ì£¼ì–´ì§„ ê·¸ë˜í”„ê°€ ì´ì§„ ê·¸ë˜í”„ì¸ì§€ í™•ì¸í•˜ëŠ” ë¬¸ì œì´ë‹¤. ì´ì§„ ê·¸ë˜í”„ë€, ë‘ ê°€ì§€ ìƒ‰ì´ ì¡´ì¬í•  ë•Œ í•œ ì •ì ì— ë¹¨ê°„ìƒ‰ì„ ì¹ í–ˆë‹¤ê³  ê°€ì •í•˜ë©´ ì¸ì ‘í•œ ì •ì ë“¤ì€ ëª¨ë‘ íŒŒë€ìƒ‰ì„ ì¹ í•´ì•¼í•œë‹¤. ì´ëŸ¬í•œ ë°©ì‹ìœ¼ë¡œ ì¹ í•´ì ¸ìˆì„ ë•Œ ëª¨ë“  ê·¸ë˜í”„ ì •ì ì˜ ì¸ì ‘í•œ ì •ì ë“¤ì˜ ìƒ‰ì´ ë‹¬ë¼ì•¼ ì´ì§„ ê·¸ë˜í”„ë¼ê³  í•  ìˆ˜ ìˆë‹¤.

ì—¬ê¸°ì„œëŠ” í’€ì´ë¥¼ ê¹Šì´ìš°ì„ íƒìƒ‰ìœ¼ë¡œ ì§„í–‰í•˜ì˜€ë‹¤. visited ë°°ì—´ì—ì„œ ë°©ë¬¸í•˜ì§€ ì•Šìœ¼ë©´ 0ìœ¼ë¡œ ì´ˆê¸°í™”ë˜ì–´ ìˆê³  ë°©ë¬¸ì‹œì—ëŠ” 1 í˜¹ì€ 2ë¡œ ì¹ í•´ì ¸ìˆë‹¤. ë”°ë¼ì„œ í•¨ìˆ˜ë¥¼ í†µí•´ì„œ ì •ì ì— ìƒ‰ê¹”ì„ ì¹ í•œ ë’¤ ê¹Šì´ìš°ì„ íƒìƒ‰ìœ¼ë¡œ ë‹¤ìŒ ì •ì ì—ì„œëŠ” í˜„ ì •ì ê³¼ëŠ” ë‹¤ë¥¸ ìƒ‰ì„ ì¹ í•´ì•¼í•œë‹¤. ì´ëŸ¬í•œ ë°˜ë³µì´ ì´ë¤„ì¡Œì„ ë•Œ ìê¸°ì™€ ì¸ì ‘í•œ ì •ì ì´ ìê¸°ì™€ ê°™ì€ ìƒ‰ê¹”ì´ë¼ë©´ í•¨ìˆ˜ë¥¼ ëë‚´ê³  boolean ê°’ì„ ë¦¬í„´í•˜ê²Œ ëœë‹¤.

ì´ ë•Œ ë°˜í™˜ëœ ê°’ì´ trueë¼ë©´ ì´ì§„ ê·¸ë˜í”„ê°€ ì•„ë‹ˆë€ ì˜ë¯¸ì´ë¯€ë¡œ, ëª©ì ì€ ë°˜ëŒ€ë¡œ ë°˜í™˜í•´ì¤˜ì•¼í•œë‹¤.

- [between-two-sets](https://www.hackerrank.com/challenges/between-two-sets)

```js
function getTotalX(a, b) {
  const min = Math.min(...a);
  const max = Math.max(...b);
  const result = [];
  const funcA = (item, x) => x % item === 0;
  const funcB = (item, x) => item % x === 0;

  for (let i = min; i <= max; i++) {
    if (a.every((el) => funcA(el, i)) && b.every((el) => funcB(el, i))) {
      result.push(i);
    }
  }

  return result.length;
}
```

aì™€ b ë‘ ë°°ì—´ì´ ì£¼ì–´ì§€ëŠ”ë° ì´ ë•Œ, a ë°°ì—´ì˜ ëª¨ë“  ì›ì†Œì— ë‚˜ëˆ„ì–´ ë–¨ì–´ì§€ë©´ì„œ b ë°°ì—´ì˜ ëª¨ë“  ì›ì†Œì— ë‚˜ëˆŒ ìˆ˜ ìˆëŠ” ìˆ«ìë¥¼ ì°¾ì•„ì•¼í•œë‹¤. ë”°ë¼ì„œ a ë°°ì—´ì˜ ìµœì†Œ ê³µë°°ìˆ˜ ë¶€í„° b ë°°ì—´ì˜ ìµœëŒ€ ê³µì•½ìˆ˜ê¹Œì§€ ì°¾ì•„ë³´ë©´ ëœë‹¤. ì‚¬ì´ì˜ aì˜ ê³µë°°ìˆ˜ë©´ì„œ bì˜ ê³µì•½ìˆ˜ì¸ ìˆ˜ë¥¼ ì°¾ê²Œë˜ëŠ”ë° ì´ ë•Œ `every()`ë¥¼ ì‚¬ìš©í•˜ë©´ í¸í•˜ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

- [Array.every()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/every)

ë°°ì—´ ì•ˆì˜ ëª¨ë“  ì›ì†Œë¥¼ íŒë³„ í•¨ìˆ˜ë¥¼ í†µê³¼í•˜ëŠ”ì§€ ì²´í¬í•´ì£¼ëŠ” ë©”ì„œë“œì´ë‹¤. ì´ ë•Œ ë¹ˆ ë°°ì—´ë„ trueë¡œ ë°˜í™˜í•´ì¤€ë‹¤ëŠ” ì ì„ ê¸°ì–µí•´ì£¼ë©´ ì¢‹ì„ ê²ƒ ê°™ë‹¤. ë”°ë¼ì„œ aì™€ bì˜ ì¡°ê±´ì— ë§ê²Œ íŒë³„ í•¨ìˆ˜ë¥¼ ë§Œë“  ë’¤ ì¡°ê±´ë¬¸ì„ í†µí•´ì„œ ë¶€í•©í•˜ëŠ” ìˆ«ìë¥¼ ì°¾ì•„ result ë°°ì—´ì— ë“±ë¡í•˜ì—¬ ê·¸ì˜ ë§ëŠ” ìˆ«ì ê°¯ìˆ˜ë¥¼ ì•Œ ìˆ˜ ìˆë‹¤.

every() ë©”ì„œë“œë¥¼ ì²˜ìŒë³´ê²Œ ë˜ì–´ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ë„ ìµí ê²¸ ê¸°ë¡í•´ë³´ì•˜ë‹¤. ìë°”ìŠ¤í¬ë¦½íŠ¸ì— ë‚´ì¥ëœ ë©”ì„œë“œë¥¼ í•˜ë‚˜í•˜ë‚˜ ì•Œì•„ê°€ëŠ” ì‹œê°„ì„ ê°€ì§€ê³  ìˆì–´ì„œ ì‘ìš©í•˜ë©´ ë‚¨ë“¤ì´ ì•Œì•„ë³´ê¸° í¸í•˜ê³  ì‰½ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆëŠ” ì½”ë“œê°€ ë‚˜ì˜¬ ê³µë¶€ê°€ ëœë‹¤.

---

- 15 æ—¥

# PS

- The K Weakest Rows in a Matrix

```cpp
bool cmp(pair<int,int> &a, pair<int,int> &b) {
    if(a.first == b.first)
        return a.second < b.second;
    return a.first < b.first;
}

class Solution {
public:

    vector<int> kWeakestRows(vector<vector<int>>& mat, int k) {
        vector<pair<int,int>> v;
        vector<int> answer;
        for(int i=0; i<mat.size(); i++) {
            int cnt = 0;
            for(int j=0; j<mat[i].size(); j++) {
                if(mat[i][j])
                    cnt++;
            }
            pair<int,int> p;
            p = {cnt, i};
            v.push_back(p);
        }
        sort(v.begin(), v.end(), cmp);
        for (int i=0; i<k; i++) {
            answer.push_back(v[i].second);
        }
        return answer;
    }
};
```

ë°°ì—´ì—ì„œ ê° rowë§ˆë‹¤ 1ì˜ ê°¯ìˆ˜ë¥¼ êµ¬í•´ì„œ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•œ ë’¤ k ê°¯ìˆ˜ë§Œí¼ì„ ë°˜í™˜í•˜ëŠ” ë¬¸ì œì´ë‹¤.

ë°”ë¡œ ìƒê°ë‚œ ë°©ë²•ì€ pairë¥¼ ì´ìš©í•˜ì—¬ row ìˆœë²ˆê³¼ 1ì˜ ê°¯ìˆ˜ë¥¼ ì •ë ¬í•˜ê³  ê°’ ê·¸ëŒ€ë¡œ ì´ìš©í•˜ëŠ” ê²ƒì´ì—ˆë‹¤.

---

# ICT ì¸í„´ì‹­ ì½”ë”©í…ŒìŠ¤íŠ¸

ì„œë¥˜ ì „í˜•ì— ì½”ë”©í…ŒìŠ¤íŠ¸ë¥¼ ì´ 5ë¬¸ì œë¡œ, í•´ì»¤ë­í¬ì—ì„œ ì§„í–‰ë˜ì—ˆë‹¤. ì•½ 3ì‹œê°„ ì •ë„ë¡œ í’€ì´ë¥¼ í–ˆëŠ”ë° ëŒ€ë¶€ë¶„ í’€ì´ë¥¼ í•˜ê³  ì‹œê°„ì´ˆê³¼ë¡œ ì¸í•´ì„œ ìƒˆë¡œ í’€ì´í•˜ë©´ì„œ ì‹œê°„ì„ ì¡ì•„ë¨¹ì—ˆë‹¤. ìƒê°í•´ë³´ë©´ ì–´ë µì§€ ì•Šì€ ë¬¸ì œë“¤ì´ì—ˆì§€ë§Œ ë°”ë¡œë°”ë¡œ ìƒê°í•´ë‚´ì§€ ëª»í–ˆë‹¤. ê·¸ ë¶€ë¶„ì— ìˆì–´ì„œëŠ” ë¬¸ì œë¥¼ ì œëŒ€ë¡œ ì´í•´í•˜ì§€ ëª»í•œ ê²Œ ìˆëŠ” ê²ƒ ê°™ë‹¤.

ë¬¸ì œê°€ ì˜ì–´ë¼ì„œ ë°”ë¡œë°”ë¡œ ëˆˆì— ë“¤ì–´ì˜¤ì§€ ì•Šì•„ì„œ ë°”ë¡œ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì— ëˆˆì´ ê°€ë²„ë¦¬ê³  ë§ì•˜ë‹¤. ê·¸ë˜ì„œ ë†“ì¹œ ë¶€ë¶„ì´ ë§ì•„ì„œ ì‹œê°„ì´ ìƒë‹¹íˆ ì†Œëª¨ë˜ì—ˆë‹¤. ì´í›„ì— í•´ì»¤ë­í¬ì—ì„œ ì§„í–‰ë˜ë©´ ì˜ì–´ë¥¼ ì¡°ê¸ˆ ë” ì—´ì‹¬íˆ ì½ì–´ì•¼ê² ë‹¤.

---

- 16 æ—¥

# PS

- Letter Case Permutation

```cpp
class Solution {
private:
    vector<string> v;
    int dif = 'a' - 'A';
public:
    void solve(string s, int idx, string temp) {
        if(idx == s.length()) {
            v.push_back(temp);
            return;
        }

        solve(s, idx+1, temp + s[idx]);

        if('a' <= s[idx] && s[idx] <= 'z') {
            char upper = s[idx] - dif;
            solve(s, idx+1, temp + upper);
        }
        else if('A' <= s[idx] && s[idx] <= 'Z') {
            char lower = s[idx] + dif;
            solve(s, idx+1, temp + lower);
        }
    }

    vector<string> letterCasePermutation(string S) {
        solve(S, 0, "");
        return v;
    }
};
```

ì£¼ì–´ì§„ ë¬¸ìì—´ ì¤‘ ì•ŒíŒŒë²³ë§Œ ëŒ€ì†Œë¬¸ìë¥¼ ë°”ê¿”ê°€ë©´ì„œ ìˆœì—´ê³¼ ê°™ì´ ë§Œë“œëŠ” ë¬¸ì œì´ë‹¤. ì›ë˜ ì•ŒíŒŒë²³ì˜ ìƒíƒœë¥¼ ë¬¸ìì—´ì— ë¶™ì—¬ì£¼ê³  ì†Œë¬¸ìë¼ë©´ ëŒ€ë¬¸ìë¥¼, ëŒ€ë¬¸ìë¼ë©´ ì†Œë¬¸ìë¥¼ ì¬ê·€ í•¨ìˆ˜ì— ë¬¸ìì—´ì„ ë¶™ì´ëŠ” ì‹ìœ¼ë¡œ ì§„í–‰í•˜ì˜€ë‹¤.

ì²˜ìŒì—ëŠ” ì—¬ëŸ¬ ê°€ì§€ ì‹œí–‰ì°©ì˜¤ê°€ ìˆì—ˆëŠ”ë°, ê·¸ ì¤‘ í•˜ë‚˜ëŠ” ë¬¸ìì—´ì— ì•ŒíŒŒë²³ì„ ì œì™¸í•œ ìˆ«ìë„ ìˆë‹¤ëŠ” ê²ƒì´ì˜€ë‹¤. ë¬¸ìì—´ ê¸¸ì´ë¥¼ ë¹„íŠ¸ë¡œ ë³€í™˜í•´ì„œ ê° ë¹„íŠ¸ ë³„ë¡œ ë¬¸ìì—´ í•˜ë‚˜í•˜ë‚˜ë¥¼ ëŒ€ì…í•˜ì—¬ ëŒ€ì†Œë¬¸ìë¥¼ ë„£ì–´ì£¼ë ¤ê³  í–ˆìœ¼ë‚˜, ìˆ«ìê°€ ë¼ì–´ìˆì–´ì„œ í„°ë¬´ë‹ˆì—†ì´ ê¸´ ì‹œê°„ì´ ê±¸ë ¸ë‹¤. ê²°êµ­ì— ë„ë‹¬í•œ ê²ƒì´ ì¬ê·€í•¨ìˆ˜ë¥¼ ì´ìš©í•œ í’€ì´ì˜€ë‹¤.

---

- 17 æ—¥

# PS

- Container With Most Water

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int answer = 0;
        int left = 0;
        int right = height.size()-1;

        while(left < right) {
            int width = min(height[left], height[right]);
            int temp = width * (right - left);
            height[left] < height[right] ? left++ : right--;
            answer = max(answer, temp);
        }
        return answer;
    }
};
```

ì£¼ì–´ì§„ ê·¸ë˜í”„ë¥¼ ê°€ì§€ê³  xì¢Œí‘œ ì¤‘ ë‘ ê³³ì„ ê³¨ë¼ì„œ ë„ˆë¹„ë¡œ, xì¢Œí‘œì— í•´ë‹¹í•˜ëŠ” ê·¸ë˜í”„ì˜ ê¸¸ì´ ì¤‘ ë” ì§§ì€ ê¸¸ì´ë¥¼ ë†’ì´ë¡œ í•˜ëŠ” ë„“ì´ë¥¼ êµ¬í•´ì•¼í•œë‹¤. ì´ ë•Œ ë„“ì´ê°€ ìµœëŒ€ê°€ ë˜ëŠ” ê°’ì„ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤.

ì œì¼ ì²˜ìŒì—ëŠ” ì´ì¤‘í¬ë¬¸ì„ í†µí•´ì„œ ëª¨ë“  ì§€ì ì„ ë‹¤ í™•ì¸í•˜ì—¬ ê°’ì„ ë°˜í™˜í–ˆìœ¼ë‚˜, ì‹œê°„ì´ˆê³¼ê°€ ì¼ì–´ë‚¬ë‹¤. ê·¸ë˜ì„œ ë‹¤ìŒì—ëŠ” ì´ì§„ íƒìƒ‰ì„ ì´ìš©í•´ì„œ ê·¸ë˜í”„ ì „ì²´ì—ì„œ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ì„ í•˜ë‚˜ì”© ì¢í˜€ê°€ë©´ì„œ ê°€ì¥ í° ë„“ì´ë¥¼ êµ¬í•˜ë„ë¡ í•˜ì˜€ë‹¤.

---

# Linux Shell Script

bash ì‰˜ì— ëŒ€í•´ì„œ ê¸°ì´ˆì ì¸ ê²ƒì„ ì ì–´ë³´ë ¤ê³  í•œë‹¤.

## ì‰˜ì´ë€?

shell ì€ ìš´ì˜ì²´ì œì˜ ì»¤ë„ê³¼ ì‚¬ìš©ì ì‚¬ì´ë¥¼ ì´ì–´ì£¼ëŠ” ì—­í• ì„ í•˜ë©°, shellì€ ìƒìš©ìì˜ ëª…ë ¹ì–´ë¥¼ í•´ì„í•˜ê³  ìš´ì˜ì²´ì œê°€ ì•Œì•„ë“¤ì„ ìˆ˜ ìˆê²Œ ì§€ì‹œí•´ì¤€ë‹¤.

ê·¸ í›„ì— ìš´ì˜ì²´ì œëŠ” shell ì—ê²Œì„œ ë°›ì€ ì§€ì‹œë¥¼ í•´ì„í•˜ì—¬ í•˜ë“œì›¨ì–´ë¥¼ ìœ„í•œ ì§€ì‹œì–´ë¡œ ë°”ê¾¸ì–´ì¤€ë‹¤.

## bash shell

### echo

```sh
#! /bin/bash

echo"print ~~"
```

printí•  ë•Œ ì‚¬ìš©í•˜ëŠ” ëª…ë ¹ì–´ë¡œ ìœ„ì™€ ê°™ì´ ì‚¬ìš©í•˜ë©´ ëœë‹¤.

### ë³€ìˆ˜ ì‚¬ìš©

```sh
#! /bin/bash

a=1
b=5
c="hello"

echo"$a $b $c"
```

ë³€ìˆ˜ëŠ” ì„ ì–¸ê³¼ ë™ì‹œì— ì •ì˜ë¥¼ í•˜ë©´ ë˜ë©°, í˜¸ì¶œì€ í„ê³¼ ìœ ì‚¬í•˜ê²Œ `$`ë¥¼ ì‚¬ìš©í•´ì„œ í˜¸ì¶œí•˜ë©´ ëœë‹¤.

### ê°’ ì…ë ¥

```sh
#! /bin/bash

echo -n "input something :"

read input

echo "$input"
```

### ì‚¬ì¹™ì—°ì‚°

```sh
#! /bin/bash

a=1
b=1

result1 = `expr $a + $b`
result2 = `expr $a - $b`
result3 = `expr $a \* $b`
result4 = `expr $a / $b`
```

ì‚¬ì¹™ì—°ì‚°ì€ ë˜‘ê°™ì´ í•˜ë˜ exprì„ ëª…ì‹œí•´ì•¼í•˜ë©°, ê³±í•˜ê¸°ì˜ ê²½ìš°ì—ëŠ” ë°±ìŠ¬ë˜ì‰¬ë¥¼ ì•ì— ì“°ê³  ì‚¬ìš©í•´ì•¼í•œë‹¤.

### ì¡°ê±´ë¬¸

- if

```sh
if [ ì¡°ê±´ ]; then
    ë‚´ìš©
elif [ ì¡°ê±´ ]; then
    ë‚´ìš©
else
    ë¬¸ì¥
fi
```

ifë¬¸ì— ì“°ì´ëŠ” ì¡°ê±´ë“¤ì€ ì „ë¶€ ì •í•´ì ¸ìˆìœ¼ë©° ê·¸ëŒ€ë¡œ ì‚¬ìš©í•´ì•¼í•œë‹¤.

`[-z]`: ë¬¸ìì—´ì˜ ê¸¸ì´ê°€ 0ì´ë©´ ì°¸, `[-n]`: ë¬¸ìì—´ì˜ ê¸¸ì´ê°€ 0ì´ ì•„ë‹ˆë©´ ì°¸.

ì´ëŸ°ì‹ìœ¼ë¡œ ì •í•´ì§„ ì¡°ê±´ë“¤ì„ í™•ì¸í•´ì•¼í•œë‹¤.

- case

```sh
case ë³€ìˆ˜ in
    ê²½ìš° 1)
    ;;
esac
```

### ë°˜ë³µë¬¸

- forë¬¸

```sh
for ë³€ìˆ˜ in ë°˜ë³µì¡°ê±´
    do
        ë‚´ìš©
    done
```

- whileë¬¸

```sh
while [ ê°’1 ì¡°ê±´ì‹ ê°’2 ]
    do
        ë‚´ìš©
    done
```

- [ë ˆí¼ëŸ°ìŠ¤](https://kangsecu.tistory.com/54)

---

- 18 æ—¥

# PS

- Arithmetic Slices

```cpp
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& A) {
        int size = A.size();
        vector<int> dp(size);
        int ans = 0;
        for(int i=2; i<size; i++) {
            if(A[i] - A[i-1] == A[i-1] - A[i-2]) {
                dp[i] = dp[i-1] + 1;
                ans += dp[i];
            }
        }
        return ans;
    }
};
```

ì¼ì •í•˜ê²Œ ì¦ê°€í•˜ëŠ” ë°°ì—´ì„ êµ¬í•˜ëŠ” ë¬¸ì œë¡œ, ë°°ì—´ì˜ ê¸¸ì´ëŠ” 3 ì´ìƒì´ë‹¤. ë”°ë¼ì„œ ì´ì–´ì§€ëŠ” ê°’ì„ ë”í•´ì£¼ê¸° ìœ„í•´ì„œ dp ë²¡í„°ë¥¼ ë§Œë“¤ì–´ì„œ ì´ì–´ì¤¬ë‹¤.

---

- 19 æ—¥

# PS

- Minimum Remove to Make Valid Parentheses

```cpp
class Solution {
public:
    string minRemoveToMakeValid(string s) {
        stack<int> st;
        string answer;
        for(int i=0; i<s.length(); i++) {
            if(s[i] == '(') {
                st.push(i);
            }
            else if(s[i] == ')') {
                if(!st.empty())
                    st.pop();
                else
                    s[i] = '+';
            }
        }
        while(!st.empty()) {
            s[st.top()] = '+';
            st.pop();
        }

        for(int i=0; i<s.length(); i++) {
            if(s[i] != '+')
                answer += s[i];
        }

        return answer;
    }
};
```

ë¬¸ìì—´ì´ ì£¼ì–´ì§€ëŠ”ë° ì´ ë–„ ì˜ëª»ëœ ê´„í˜¸ê°€ ìˆìœ¼ë©´ ì „ë¶€ ì§€ìš°ê³  ì˜¨ì „í•œ ê´„í˜¸ë§Œ í¬í•¨í•œ ì±„ë¡œ ë¬¸ìì—´ì„ ë°˜í™˜í•˜ëŠ” ë¬¸ì œì´ë‹¤. ì²˜ìŒì—ëŠ” ë‹«íŒ ê´„í˜¸ì—ë§Œ ì‹ ê²½ ì¼ë”ë‹ˆ `))((`ì™€ ê°™ì€ ì˜ˆì œì—ëŠ” ë¬¸ì œê°€ ìˆì—ˆë‹¤.

ì´í›„ì— ìƒê°í•œ ê²ƒì€ ë¬¸ìì—´ì—ì„œ ë¬¸ì œìˆëŠ” ë¶€ë¶„ì„ ì „ë¶€ `+`ë¡œ ë°”ê¿”ë²„ë¦¬ëŠ” ê²ƒì´ë‹¤. ê·¸ë ‡ê²Œí•˜ë©´ ì§ì„ ê°€ì§€ì§€ ëª»í•œ ê´„í˜¸ë“¤ì„ ì „ë¶€ ë°”ê¿€ ìˆ˜ ìˆì—ˆë‹¤. ì´í›„ì— ë§ˆì§€ë§‰ì— ë°˜í™˜í•˜ëŠ” ë¬¸ìì—´ì— ê·¸ ë¶€ë¶„ì„ í¬í•¨í•˜ì§€ ì•Šìœ¼ë©´ ì›í•˜ëŠ” ë¬¸ìì—´ì„ ì–»ì„ ìˆ˜ ìˆë‹¤.

---

- 20 æ—¥

# PS

- Roman to Integer

```cpp
class Solution {
public:
    int romanToInt(string s) {
        int result = 0;
        map<char, int> m;
        m.insert({'I', 1});
        m.insert({'V', 5});
        m.insert({'X', 10});
        m.insert({'L', 50});
        m.insert({'C', 100});
        m.insert({'D', 500});
        m.insert({'M', 1000});

        for(int i=0; i<s.length()-1; i++) {
            int cur = m[s[i]];
            int next = m[s[i+1]];

            cur >= next ? result += cur : result -= cur;
        }
        result += m[s[s.length()-1]];
        return result;
    }
};
```

ë¡œë§ˆìë¥¼ ìˆ«ìë¡œ ë³€í™˜í•˜ëŠ” ë¬¸ì œì´ë‹¤. ì‰½ê²Œ ìƒê°í•´ì„œ ë’¤ì— ë‚˜ì˜¤ëŠ” ë¬¸ìê°€ í˜„ì¬ ë¬¸ìë³´ë‹¤ í¬ë©´ ê²°ê³¼ê°’ì—ì„œ ë¹¼ì£¼ê³  í¬ê±°ë‚˜ ê°™ìœ¼ë©´ ë”í•´ì£¼ëŠ” ë°©ì‹ìœ¼ë¡œ í’€ì–´ì¤¬ë‹¤. mapì„ ì´ìš©í•˜ì—¬ ì¡°ê¸ˆ ë” ì§ê´€ì ìœ¼ë¡œ í•´ê²°í•˜ì˜€ë‹¤.

---

- 21 æ—¥

# PS

- Broken Calculator

```cpp
class Solution {
public:
    int brokenCalc(int X, int Y) {
        int result = 0;

        while(Y > X) {
            if(Y&1) {
                Y++;
            }
            else {
                Y /= 2;
            }
            result++;
        }
        return result + X - Y;
    }
};
```

ê³„ì‚°ê¸°ê°€ ê³ ì¥ë‚˜ì„œ ìˆ«ìì— 1ì„ ë¹¼ê±°ë‚˜ 2ë¥¼ ê³±í•˜ëŠ” ë°©ë²•ë°–ì— ì—†ëŠ” ìƒí™©ì—ì„œ Xë¥¼ Yì™€ ê°™ê²Œ ë§Œë“œëŠ” ë¬¸ì œì´ë‹¤. ì²˜ìŒì—ëŠ” íë¥¼ ì´ìš©í•˜ì˜€ì§€ë§Œ ì‹œê°„ ì´ˆê³¼ë¡œ ì¸í•´ì„œ ë‹¤ë¥¸ ì‚¬ëŒ ì½”ë“œë¥¼ ì°¸ì¡°í•˜ì—¬ í’€ì–´ë³´ì•˜ë‹¤. ì£¼ì²´ë¥¼ Xê°€ ì•„ë‹Œ Yë¡œ ë‘ê³  Yê°€ í™€ìˆ˜ ì¼ë•Œ 1ì„ ë”í•´ì„œ ì§ìˆ˜ë¡œ ë§Œë“¤ì–´ì£¼ê³  ì§ìˆ˜ì¼ ë•ŒëŠ” 2ë¡œ ë‚˜ëˆ„ì–´ì¡Œë‹¤. ë°˜ë³µì¡°ê±´ì€ Xê°€ Yë³´ë‹¤ ì‘ì„ ë•Œë§Œ ë°˜ë³µí•˜ê²Œ í•˜ì—¬ ê·¸ ë°˜ë³µ íšŸìˆ˜ì™€ Xì™€ Yì˜ ì°¨ì´ë¥¼ ë”í•´ ê°’ì„ êµ¬í–ˆë‹¤.

ì²˜ìŒì—ëŠ” ì´í•´í•˜ê¸° ì–´ë ¤ì› ìœ¼ë‚˜, ê¸°ëŠ¥ ë‘ ê°€ì§€ë¥¼ í™œìš©í•˜ì—¬ Xë³´ë‹¤ Yë¥¼ ì‘ê²Œ ë§Œë“¤ì–´ì„œ ê·¸ ì°¨ì´ëŠ” ë¬´ì¡°ê±´ í•œ ê¸°ëŠ¥ì„ ì´ìš©í•˜ê¸° ë•Œë¬¸ì— ê·¸ ê³¼ì •ì„ ì´ìš©í•œ ê²ƒì„ ì•Œ ìˆ˜ ìˆì—ˆë‹¤.

---

- 22 æ—¥

# PS

- Longest Word in Dictionary through Deleting

```cpp
class Solution {
public:
   bool isSubsequence(string s1, string s2){
      int j = 0;
      for(int i = 0; i < s1.size(); i++){
         if(s2[j] == s1[i]){
            j++;
            if(j == s2.size()) break;
         }
      }
      return j == s2.size();
   }
   string findLongestWord(string s, vector<string>& d) {
      string ans = "";
      for(int i = 0; i < d.size(); i++){
         string x = d[i];
         if(x.size() > ans.size() || (x.size() == ans.size() && (x < ans))){
            if(isSubsequence(s, x)) ans = x;
         }
      }
      return ans;
   }
};
```

ì£¼ì–´ì§„ ë¬¸ìì—´ì—ì„œ ë¬¸ìë“¤ì„ ì‚­ì œí•´ì„œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ë‹¨ì–´ ì¤‘ ê°€ì¥ ê¸´ ë‹¨ì–´ë¥¼ d ë°°ì—´ì—ì„œ ë½‘ì•„ì„œ ë°˜í™˜í•´ì•¼í•œë‹¤. ì´ ë•Œ ê¸¸ì´ê°€ ê°™ë‹¤ë©´ ì‚¬ì „ì  ì •ì˜ê°€ ì•ì¸ ë‹¨ì–´ë¥¼ ë°˜í™˜í•˜ë©´ ëœë‹¤.

ì²˜ìŒì— ì‹œë„í•œ ë°©ë²•ì€ ì•ŒíŒŒë²³ ìˆ˜ë¥¼ ì „ë¶€ ì„¸ì„œ ë°°ì—´ë¡œì¨ ê°€ì§€ê³  ê°¯ìˆ˜ë¥¼ ì¶©ì¡±í•˜ë‚˜ë¥¼ ì°¾ì•„ì£¼ì—ˆë‹¤. í•˜ì§€ë§Œ, ì—¬ê¸°ì„œ ê°„ê³¼í•œ ì ì´ ìˆì—ˆë‹¤. ë°”ë¡œ, ë¬¸ìì—´ì˜ ë¶€ë¶„ìˆ˜ì—´ì— ì†í•´ì•¼í•˜ëŠ” ê²ƒì´ì—ˆë‹¤. ë¬¸ìì—´ì—ì„œ ë¬¸ìë“¤ì„ ì‚­ì œí•œë‹¤ê³  ë¬¸ìë“¤ì˜ ìë¦¬ê°€ ì¬ë°°ì—´ë˜ì§€ëŠ” ì•ŠëŠ”ë‹¤. ë”°ë¼ì„œ ê°™ì€ ì•ŒíŒŒë²³ ìˆ«ìë¥¼ ê°€ì§€ê³  ìˆëŠ” ê²ƒì´ì•„ë‹ˆë¼ ë¶€ë¶„ìˆ˜ì—´ì¤‘ì—ì„œ ê°€ì¥ í¬ê¸°ê°€ ê¸¸ë©´ì„œë„ ì‚¬ì „ì  ì •ì˜ê°€ ì•ì— ìœ„ì¹˜í•œ ë‹¨ì–´ë¥¼ ì°¾ì•„ì¤˜ì•¼í•˜ëŠ” ë¬¸ì œì˜€ë‹¤.

---

- 23 æ—¥

# PS

- Search a 2D Matrix II

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row = matrix.size();
        int col = matrix[0].size();

        int i = 0;
        int j = col - 1;

        while(i < row && j >= 0) {
            if(matrix[i][j] < target)
                i++;
            else if(matrix[i][j] > target)
                j--;
            else
                return true;
        }
        return false;
    }
};
```

ë°°ì—´ì´ ì£¼ì–´ì§€ëŠ”ë° ì´ ë°°ì—´ì˜ í–‰ê³¼ ì—´ì´ ê°ê° ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì–´ ìˆë‹¤. ê·¸ ë°°ì—´ì—ì„œ ì£¼ì–´ì§„ targetì´ë€ ê°’ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë¬¸ì œì´ë‹¤. ìµœì•…ì˜ ê²½ìš° O(n^2) ì‹œê°„ë³µì¡ë„ê°€ ê±¸ë¦¬ëŠ”ë° ë°°ì—´ì˜ í¬ê¸°ê°€ `-10^9 <= target <= 10^9`ì´ë¯€ë¡œ ì‹œê°„ì´ ì—„ì²­ ê±¸ë¦°ë‹¤.

ë”°ë¼ì„œ targetì„ ì°¾ê¸° ìœ„í•´ì„œ ì˜¤ë¥¸ìª½ ìœ„ë¶€í„° targetë³´ë‹¤ í˜„ì¬ ìˆ«ìê°€ ì‘ìœ¼ë©´ ì—´ì˜ ì¸ë±ìŠ¤ë¥¼ ì¦ê°€ì‹œí‚¤ê³  í˜„ì¬ ìˆ«ìê°€ í¬ë‹¤ë©´ ê·¸ í–‰ì— ìˆë‹¤ëŠ” ë§ì´ë¯€ë¡œ í•´ë‹¹ í–‰ì—ì„œ targetì„ ì°¾ëŠ” ì‹ìœ¼ë¡œ êµ¬í˜„í•˜ì˜€ë‹¤.

---

- ì •ë³´ì²˜ë¦¬ê¸°ì‚¬

ìš”ì¦˜ì—ëŠ” ì •ë³´ì²˜ë¦¬ê¸°ì‚¬ í•„ê¸°ë¥¼ ì‹œí—˜ë³´ê¸° ìœ„í•´ì„œ ê³µë¶€ ì¤‘ì¸ë°, ê³¼ëª© 1,2ì„ ìœ„ì£¼ë¡œ ê³µë¶€ì¤‘ì´ë‹¤. í•™êµ ê°•ì˜ë¡œëŠ” ì†Œí”„íŠ¸ì›¨ì–´ê³µí•™ ê³¼ëª©ì— ì†í•œ ë‚´ìš©ì¸ë° í•™êµ ê°•ì˜ì—ì„œë„ ë§ˆì°¬ê°€ì§€ë¡œ ì™¸ì›Œì•¼í•˜ëŠ” í•­ëª©ë“¤ì´ ë„ˆë¬´ ë§ì•„ì„œ ì¡°ê¸ˆ ì–´ë ¤ì›Œí•˜ê³  ìˆë‹¤.

---

- 24 æ—¥

# PS

- `1074. Z`

```cpp
#include <bits/stdc++.h>
using namespace std;

int N, r, c, cnt;

void sol(int size, int y, int x) {
    if(y == r && x == c) {
        cout << cnt;
        return;
    }
    if(size == 1) {
        cnt++;
        return;
    }
    if(y > r || r >= y+size || x > c || c >= x+size) {
        cnt += size * size;
        return;
    }

	sol(size/2,y,x);
	sol(size/2,y,x+size/2);
	sol(size/2,y+size/2,x);
	sol(size/2,y+size/2,x+size/2);

}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cin >> N >> r >> c;
	sol(pow(2,N),0,0);
}
```

ì¬ì±„ì ìœ¼ë¡œ ì¸í•´ ì‹œê°„ì´ˆê³¼ë¡œ ì˜¤ë‹µìœ¼ë¡œ ë‚˜ì™€ ë‹¤ì‹œ í’€ì´ë¥¼ í•´ë³´ì•˜ë‹¤. ë¶„í• ì •ë³µì„ ì´ìš©í•´ì„œ í’€ì´ë¥¼ í•˜ì˜€ìœ¼ë‚˜, ì‹œê°„ì„ ì¤„ì´ê¸° ìœ„í•´ì„œ ë¶„í•  ì‹œì— í¬ê¸°ê°€ 1ì¸ ëœ ê²½ìš°ë¥¼ 1ê°œë¡œ ë³´ê³ , í•´ë‹¹ ì‚¬ë¶„ë©´ì„ ë‹¤ ì²´í¬í•œ ê²½ìš°ì—ëŠ” ì‚¬ë¶„ë©´ í¬ê¸°ë§Œí¼ì„ ë‹µì— ë”í•´ì£¼ì—ˆë‹¤. ì „ì—ëŠ” ì‚¬ë¶„ë©´ì´ ì•„ë‹Œ í•˜ë‚˜í•˜ë‚˜ë¥¼ ì „ë¶€ ì²´í¬í•˜ì—¬ ì‹œê°„ì´ ë¶€ì¡±í•˜ì˜€ë˜ ê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤.

---

- 25 æ—¥

# PS

- Shortest Unsorted Continuous Subarray

```cpp
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        int size = nums.size();
        int left = -1, right = -1;
        int max = -10e5;
        int min = 10e5;

        for(int i=0; i<size; i++) {
            if(max < nums[i])
                max = nums[i];
            else if(max > nums[i])
                left = i;
        }

        for(int i=size-1; i>=0; i--) {
            if(min > nums[i])
                min = nums[i];
            else if(min < nums[i])
                right = i;
        }

        if(left == -1)
            return 0;
        return abs(right - left - 1);
    }
};
```

ì£¼ì–´ì§„ ë°°ì—´ì„ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ë°”ê¿”ì•¼í•  ë•Œ, ê°€ì¥ ì ê²Œ ì˜®ê²¨ì„œ ì˜¤ë¦„ì°¨ìˆœì„ ë§Œë“¤ ìˆ˜ ìˆëŠ” íšŸìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤. ë”°ë¼ì„œ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ì—ì„œ ê°ê° ìµœëŒ“ê°’ê³¼ ìµœì†Ÿê°’ì„ ì´ìš©í•´ì„œ í•´ë‹¹ ê°’ì´ ì—­ì „ë˜ëŠ” ì¸ë±ìŠ¤ë¥¼ ì°¾ì•„ì„œ ì¸ë±ìŠ¤ ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ êµ¬í•˜ì˜€ë‹¤.

---
